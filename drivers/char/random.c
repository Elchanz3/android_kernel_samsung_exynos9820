// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
/*
<<<<<<< HEAD
 * random.c -- A strong random number generator
 *
 * Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All
 * Rights Reserved.
 *
=======
 * Copyright (C) 2017-2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
>>>>>>> fabaab48f24c (random: add proper SPDX header)
 * Copyright Matt Mackall <mpm@selenic.com>, 2003, 2004, 2005
<<<<<<< HEAD
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.  All
 * rights reserved.
 */

/*
<<<<<<< HEAD
 * (now, with legal B.S. out of the way.....)
 *
 * This routine gathers environmental noise from device drivers, etc.,
 * and returns good random numbers, suitable for cryptographic use.
 * Besides the obvious cryptographic uses, these numbers are also good
 * for seeding TCP sequence numbers, and other places where it is
 * desirable to have numbers which are not only random, but hard to
 * predict by an attacker.
 *
 * Theory of operation
 * ===================
 *
 * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truly random numbers on a computer --- as opposed to
 * pseudo-random numbers, which can easily generated by using a
 * algorithm.  Unfortunately, it is very easy for attackers to guess
 * the sequence of pseudo-random number generators, and for some
 * applications this is not acceptable.  So instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard for outside attackers to observe, and use that to
 * generate random numbers.  In a Unix environment, this is best done
 * from inside the kernel.
 *
 * Sources of randomness from the environment include inter-keyboard
 * timings, inter-interrupt timings from some interrupts, and other
 * events which are both (a) non-deterministic and (b) hard for an
 * outside observer to measure.  Randomness from these sources are
 * added to an "entropy pool", which is mixed using a CRC-like function.
 * This is not cryptographically strong, but it is adequate assuming
 * the randomness is not chosen maliciously, and it is fast enough that
 * the overhead of doing it on every interrupt is very reasonable.
 * As random bytes are mixed into the entropy pool, the routines keep
 * an *estimate* of how many bits of randomness have been stored into
 * the random number generator's internal state.
 *
 * When random bytes are desired, they are obtained by taking the SHA
 * hash of the contents of the "entropy pool".  The SHA hash avoids
 * exposing the internal state of the entropy pool.  It is believed to
 * be computationally infeasible to derive any useful information
 * about the input of SHA from its output.  Even if it is possible to
 * analyze SHA in some clever way, as long as the amount of data
 * returned from the generator is less than the inherent entropy in
 * the pool, the output data is totally unpredictable.  For this
 * reason, the routine decreases its internal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outputs random numbers.
 *
 * If this estimate goes to zero, the routine can still generate
 * random numbers; however, an attacker may (at least in theory) be
 * able to infer the future output of the generator from prior
 * outputs.  This requires successful cryptanalysis of SHA, which is
 * not believed to be feasible, but there is a remote possibility.
 * Nonetheless, these numbers should be useful for the vast majority
 * of purposes.
 *
=======
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
 * Exported interfaces ---- output
 * ===============================
 *
 * There are three exported interfaces; the first is one designed to
 * be used from within the kernel:
 *
 * 	void get_random_bytes(void *buf, int nbytes);
 *
 * This interface will return the requested number of random bytes,
 * and place it in the requested buffer.
 *
 * The two other interfaces are two character devices /dev/random and
 * /dev/urandom.  /dev/random is suitable for use when very high
 * quality randomness is desired (for example, for key generation or
 * one-time pads), as it will only return a maximum of the number of
 * bits of randomness (as estimated by the random number generator)
 * contained in the entropy pool.
 *
 * The /dev/urandom device does not have this limit, and will return
 * as many bytes as are requested.  As more and more random bytes are
 * requested without giving time for the entropy pool to recharge,
 * this will result in random numbers that are merely cryptographically
 * strong.  For many applications, however, this is acceptable.
 *
<<<<<<< HEAD
=======
 * Exported interfaces ---- kernel output
 * --------------------------------------
 *
 * The primary kernel interfaces are:
 *
 *	void get_random_bytes(void *buf, size_t nbytes);
 *	u32 get_random_u32()
 *	u64 get_random_u64()
 *	unsigned int get_random_int()
 *	unsigned long get_random_long()
 *
 * These interfaces will return the requested number of random bytes
 * into the given buffer or as a return value. This is equivalent to a
 * read from /dev/urandom. The get_random_{u32,u64,int,long}() family
 * of functions may be higher performance for one-off random integers,
 * because they do a bit of buffering.
 *
 * prandom_u32()
 * -------------
 *
 * For even weaker applications, see the pseudorandom generator
 * prandom_u32(), prandom_max(), and prandom_bytes().  If the random
 * numbers aren't security-critical at all, these are *far* cheaper.
 * Useful for self-tests, random error simulation, randomized backoffs,
 * and any other application where you trust that nobody is trying to
 * maliciously mess with you by guessing the "random" numbers.
 *
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
 * Exported interfaces ---- input
 * ==============================
 *
 * The current exported interfaces for gathering environmental noise
 * from the devices are:
 *
 *	void add_device_randomness(const void *buf, size_t size);
 *	void add_input_randomness(unsigned int type, unsigned int code,
 *                                unsigned int value);
<<<<<<< HEAD
 *	void add_interrupt_randomness(int irq, int irq_flags);
 * 	void add_disk_randomness(struct gendisk *disk);
=======
 *	void add_interrupt_randomness(int irq);
 *	void add_disk_randomness(struct gendisk *disk);
 *	void add_hwgenerator_randomness(const void *buffer, size_t count,
 *					size_t entropy);
<<<<<<< HEAD
 *	void add_bootloader_randomness(const void *buf, unsigned int size);
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
=======
 *	void add_bootloader_randomness(const void *buf, size_t size);
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
 *
 * add_device_randomness() is for adding data to the random pool that
 * is likely to differ between two devices (or possibly even per boot).
 * This would be things like MAC addresses or serial numbers, or the
 * read-out of the RTC. This does *not* add any actual entropy to the
 * pool, but it initializes the pool to different values for devices
 * that might otherwise be identical and have very little entropy
 * available to them (particularly common in the embedded world).
 *
 * add_input_randomness() uses the input layer interrupt timing, as well as
 * the event type information from the hardware.
 *
 * add_interrupt_randomness() uses the interrupt timing as random
 * inputs to the entropy pool. Using the cycle counters and the irq source
 * as inputs, it feeds the randomness roughly once a second.
 *
 * add_disk_randomness() uses what amounts to the seek time of block
 * layer request events, on a per-disk_devt basis, as input to the
 * entropy pool. Note that high-speed solid state drives with very low
 * seek times do not make for good sources of entropy, as their seek
 * times are usually fairly consistent.
 *
 * All of these routines try to estimate how many bits of randomness a
 * particular randomness source.  They do this by keeping track of the
 * first and second order deltas of the event timings.
 *
 * Ensuring unpredictability at system startup
 * ============================================
 *
 * When any operating system starts up, it will go through a sequence
 * of actions that are fairly predictable by an adversary, especially
 * if the start-up does not involve interaction with a human operator.
 * This reduces the actual number of bits of unpredictability in the
 * entropy pool below the value in entropy_count.  In order to
 * counteract this effect, it helps to carry information in the
 * entropy pool across shut-downs and start-ups.  To do this, put the
 * following lines an appropriate script which is run during the boot
 * sequence:
 *
 *	echo "Initializing random number generator..."
 *	random_seed=/var/run/random-seed
 *	# Carry a random seed from start-up to start-up
 *	# Load and then save the whole entropy pool
 *	if [ -f $random_seed ]; then
 *		cat $random_seed >/dev/urandom
 *	else
 *		touch $random_seed
 *	fi
 *	chmod 600 $random_seed
 *	dd if=/dev/urandom of=$random_seed count=1 bs=512
 *
 * and the following lines in an appropriate script which is run as
 * the system is shutdown:
 *
 *	# Carry a random seed from shut-down to start-up
 *	# Save the whole entropy pool
 *	echo "Saving random seed..."
 *	random_seed=/var/run/random-seed
 *	touch $random_seed
 *	chmod 600 $random_seed
 *	dd if=/dev/urandom of=$random_seed count=1 bs=512
 *
 * For example, on most modern systems using the System V init
 * scripts, such code fragments would be found in
 * /etc/rc.d/init.d/random.  On older Linux systems, the correct script
 * location might be in /etc/rcb.d/rc.local or /etc/rc.d/rc.0.
 *
 * Effectively, these commands cause the contents of the entropy pool
 * to be saved at shut-down time and reloaded into the entropy pool at
 * start-up.  (The 'dd' in the addition to the bootup script is to
 * make sure that /etc/random-seed is different for every start-up,
 * even if the system crashes without executing rc.0.)  Even with
 * complete knowledge of the start-up activities, predicting the state
 * of the entropy pool requires knowledge of the previous history of
 * the system.
 *
 * Configuring the /dev/random driver under Linux
 * ==============================================
 *
 * The /dev/random driver under Linux uses minor numbers 8 and 9 of
 * the /dev/mem major number (#1).  So if your system does not have
 * /dev/random and /dev/urandom created already, they can be created
 * by using the commands:
 *
 *	mknod /dev/random c 1 8
 *	mknod /dev/urandom c 1 9
=======
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999. All rights reserved.
 *
 * This driver produces cryptographically secure pseudorandom data. It is divided
 * into roughly six sections, each with a section header:
 *
 *   - Initialization and readiness waiting.
 *   - Fast key erasure RNG, the "crng".
 *   - Entropy accumulation and extraction routines.
 *   - Entropy collection routines.
 *   - Userspace reader/writer interfaces.
 *   - Sysctl interface.
 *
 * The high level overview is that there is one input pool, into which
 * various pieces of data are hashed. Some of that data is then "credited" as
 * having a certain number of bits of entropy. When enough bits of entropy are
 * available, the hash is finalized and handed as a key to a stream cipher that
 * expands it indefinitely for various consumers. This key is periodically
 * refreshed as the various entropy collectors, described below, add data to the
 * input pool and credit it. There is currently no Fortuna-like scheduler
 * involved, which can lead to malicious entropy sources causing a premature
 * reseed, and the entropy estimates are, at best, conservative guesses.
>>>>>>> b3fa3d153ad2 (random: rewrite header introductory comment)
 */

#include <linux/utsname.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/major.h>
#include <linux/string.h>
#include <linux/fcntl.h>
#include <linux/slab.h>
#include <linux/random.h>
#include <linux/poll.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/genhd.h>
#include <linux/interrupt.h>
#include <linux/mm.h>
#include <linux/nodemask.h>
#include <linux/spinlock.h>
#include <linux/kthread.h>
#include <linux/percpu.h>
#include <linux/cryptohash.h>
#include <linux/fips.h>
#include <linux/ptrace.h>
#include <linux/workqueue.h>
#include <linux/irq.h>
#include <linux/ratelimit.h>
#include <linux/syscalls.h>
#include <linux/completion.h>
#include <linux/uuid.h>
<<<<<<< HEAD
#include <linux/freezer.h>
#include <crypto/chacha20.h>

=======
#include <linux/uaccess.h>
#include <crypto/chacha20.h>
#include <crypto/blake2s.h>
>>>>>>> ee5705cffcc8 (random: remove whitespace and reorder includes)
#include <asm/processor.h>
#include <asm/irq.h>
#include <asm/irq_regs.h>
#include <asm/io.h>

<<<<<<< HEAD
<<<<<<< HEAD
#define CREATE_TRACE_POINTS
#include <trace/events/random.h>

<<<<<<< HEAD
/* #define ADD_INTERRUPT_BENCH */

<<<<<<< HEAD
<<<<<<< HEAD
/*
<<<<<<< HEAD
 * Configuration information
 */
#define INPUT_POOL_SHIFT	12
#define INPUT_POOL_WORDS	(1 << (INPUT_POOL_SHIFT-5))
#define OUTPUT_POOL_SHIFT	10
#define OUTPUT_POOL_WORDS	(1 << (OUTPUT_POOL_SHIFT-5))
#define SEC_XFER_SIZE		512
#define EXTRACT_SIZE		10


#define LONGS(x) (((x) + sizeof(unsigned long) - 1)/sizeof(unsigned long))

/*
 * To allow fractional bits to be tracked, the entropy_count field is
 * denominated in units of 1/8th bits.
 *
<<<<<<< HEAD
 * 2*(ENTROPY_SHIFT + log2(poolbits)) must <= 31, or the multiply in
 * credit_entropy_bits() needs to be 64 bits wide.
 */
#define ENTROPY_SHIFT 3
#define ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)

/*
 * The minimum number of bits of entropy before we wake up a read on
 * /dev/random.  Should be enough to do a significant reseed.
 */
static int random_read_wakeup_bits = 64;
=======
 * 2*(POOL_ENTROPY_SHIFT + poolbitshift) must <= 31, or the multiply in
 * credit_entropy_bits() needs to be 64 bits wide.
 */
#define POOL_ENTROPY_SHIFT 3
#define POOL_ENTROPY_BITS() (input_pool.entropy_count >> POOL_ENTROPY_SHIFT)
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)

/*
=======
>>>>>>> 563845199476 (random: cleanup fractional entropy shift constants)
 * If the entropy count falls under this number of bits, then we
 * should wake up processes which are selecting or polling on write
 * access to /dev/random.
 */
static int random_write_wakeup_bits = 28 * OUTPUT_POOL_WORDS;

/*
 * Originally, we used a primitive polynomial of degree .poolwords
 * over GF(2).  The taps for various sizes are defined below.  They
 * were chosen to be evenly spaced except for the last tap, which is 1
 * to get the twisting happening as fast as possible.
 *
 * For the purposes of better mixing, we use the CRC-32 polynomial as
 * well to make a (modified) twisted Generalized Feedback Shift
 * Register.  (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR
 * generators.  ACM Transactions on Modeling and Computer Simulation
 * 2(3):179-194.  Also see M. Matsumoto & Y. Kurita, 1994.  Twisted
 * GFSR generators II.  ACM Transactions on Modeling and Computer
 * Simulation 4:254-266)
 *
 * Thanks to Colin Plumb for suggesting this.
 *
 * The mixing operation is much less sensitive than the output hash,
 * where we use SHA-1.  All that we want of mixing operation is that
 * it be a good non-cryptographic hash; i.e. it not produce collisions
 * when fed "random" data of the sort we expect to see.  As long as
 * the pool state differs for different inputs, we have preserved the
 * input entropy and done a good job.  The fact that an intelligent
 * attacker can construct inputs that will produce controlled
 * alterations to the pool's state is not important because we don't
 * consider such inputs to contribute any randomness.  The only
 * property we need with respect to them is that the attacker can't
 * increase his/her knowledge of the pool's state.  Since all
 * additions are reversible (knowing the final state and the input,
 * you can reconstruct the initial state), if an attacker has any
 * uncertainty about the initial state, he/she can only shuffle that
 * uncertainty about, but never cause any collisions (which would
 * decrease the uncertainty).
 *
 * Our mixing functions were analyzed by Lacharme, Roeck, Strubel, and
 * Videau in their paper, "The Linux Pseudorandom Number Generator
 * Revisited" (see: http://eprint.iacr.org/2012/251.pdf).  In their
 * paper, they point out that we are not using a true Twisted GFSR,
 * since Matsumoto & Kurita used a trinomial feedback polynomial (that
 * is, with only three taps, instead of the six that we are using).
 * As a result, the resulting polynomial is neither primitive nor
 * irreducible, and hence does not have a maximal period over
 * GF(2**32).  They suggest a slight change to the generator
 * polynomial which improves the resulting TGFSR polynomial to be
 * irreducible, which we have made here.
 */
<<<<<<< HEAD
static struct poolinfo {
	int poolbitshift, poolwords, poolbytes, poolbits, poolfracbits;
#define S(x) ilog2(x)+5, (x), (x)*4, (x)*32, (x) << (ENTROPY_SHIFT+5)
	int tap1, tap2, tap3, tap4, tap5;
} poolinfo_table[] = {
	/* was: x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 */
=======
=======
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
enum poolinfo {
	POOL_BITS = BLAKE2S_HASH_SIZE * 8,
	POOL_BITSHIFT = ilog2(POOL_BITS),
	POOL_MIN_BITS = POOL_BITS / 2,

	/* To allow fractional bits to be tracked, the entropy_count field is
	 * denominated in units of 1/8th bits. */
	POOL_ENTROPY_SHIFT = 3,
#define POOL_ENTROPY_BITS() (input_pool.entropy_count >> POOL_ENTROPY_SHIFT)
<<<<<<< HEAD
<<<<<<< HEAD
	POOL_FRACBITS = POOL_BITS << POOL_ENTROPY_SHIFT,

>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
	/* x^128 + x^104 + x^76 + x^51 +x^25 + x + 1 */
	{ S(128),	104,	76,	51,	25,	1 },
	/* was: x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 */
	/* x^32 + x^26 + x^19 + x^14 + x^7 + x + 1 */
	{ S(32),	26,	19,	14,	7,	1 },
#if 0
	/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */
	{ S(2048),	1638,	1231,	819,	411,	1 },

	/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */
	{ S(1024),	817,	615,	412,	204,	1 },

	/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */
	{ S(1024),	819,	616,	410,	207,	2 },

	/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */
	{ S(512),	411,	308,	208,	104,	1 },

	/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */
	{ S(512),	409,	307,	206,	102,	2 },
	/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */
	{ S(512),	409,	309,	205,	103,	2 },

	/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */
	{ S(256),	205,	155,	101,	52,	1 },

	/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */
	{ S(128),	103,	78,	51,	27,	2 },

	/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */
	{ S(64),	52,	39,	26,	14,	1 },
#endif
=======
	POOL_FRACBITS = POOL_BITS << POOL_ENTROPY_SHIFT
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
=======
	POOL_FRACBITS = POOL_BITS << POOL_ENTROPY_SHIFT,
	POOL_MIN_FRACBITS = POOL_MIN_BITS << POOL_ENTROPY_SHIFT
>>>>>>> 62a2b4bd3ec9 (random: simplify entropy debiting)
=======
=======
>>>>>>> f8a196cf4751 (random: remove ifdef'd out interrupt bench)
=======
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
enum {
	POOL_BITS = BLAKE2S_HASH_SIZE * 8,
	POOL_MIN_BITS = POOL_BITS /* No point in settling for less. */
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
};

/*
 * Static global variables
 */
static DECLARE_WAIT_QUEUE_HEAD(random_read_wait);
static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
static struct fasync_struct *fasync;

static DEFINE_SPINLOCK(random_ready_list_lock);
static LIST_HEAD(random_ready_list);
=======
/*********************************************************************
 *
 * Initialization and readiness waiting.
 *
 * Much of the RNG infrastructure is devoted to various dependencies
 * being able to wait until the RNG has collected enough entropy and
 * is ready for safe consumption.
 *
 *********************************************************************/
>>>>>>> 25061d366b70 (random: group initialization wait functions)

<<<<<<< HEAD
struct crng_state {
<<<<<<< HEAD
	__u32		state[16];
	unsigned long	init_time;
	spinlock_t	lock;
=======
	u32 state[16];
	unsigned long init_time;
	spinlock_t lock;
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
};

struct crng_state primary_crng = {
	.lock = __SPIN_LOCK_UNLOCKED(primary_crng.lock),
};

=======
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
/*
 * crng_init =  0 --> Uninitialized
 *		1 --> Initialized
 *		2 --> Initialized from input_pool
 *
 * crng_init is protected by base_crng->lock, and only increases
 * its value (from 0->1->2).
 */
static int crng_init = 0;
#define crng_ready() (likely(crng_init > 1))
<<<<<<< HEAD
static int crng_init_cnt = 0;
<<<<<<< HEAD
<<<<<<< HEAD
static unsigned long crng_global_init_time = 0;
<<<<<<< HEAD
#define CRNG_INIT_CNT_THRESH (2*CHACHA20_KEY_SIZE)
static void _extract_crng(struct crng_state *crng,
			  __u8 out[CHACHA20_BLOCK_SIZE]);
=======
#define CRNG_INIT_CNT_THRESH (2 * CHACHA20_KEY_SIZE)
static void _extract_crng(struct crng_state *crng, u8 out[CHACHA20_BLOCK_SIZE]);
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
static void _crng_backtrack_protect(struct crng_state *crng,
				    __u8 tmp[CHACHA20_BLOCK_SIZE], int used);
=======
#define CRNG_INIT_CNT_THRESH (2 * CHACHA20_KEY_SIZE)
static void extract_crng(u8 out[CHACHA20_BLOCK_SIZE]);
static void crng_backtrack_protect(u8 tmp[CHACHA20_BLOCK_SIZE], int used);
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
=======
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
static void process_random_ready_list(void);
static void _get_random_bytes(void *buf, size_t nbytes);
=======
/* Various types of waiters for crng_init->2 transition. */
static DECLARE_WAIT_QUEUE_HEAD(crng_init_wait);
static struct fasync_struct *fasync;
static DEFINE_SPINLOCK(random_ready_list_lock);
static LIST_HEAD(random_ready_list);
>>>>>>> 25061d366b70 (random: group initialization wait functions)

/* Control how we warn userspace. */
static struct ratelimit_state unseeded_warning =
	RATELIMIT_STATE_INIT("warn_unseeded_randomness", HZ, 3);
static struct ratelimit_state urandom_warning =
	RATELIMIT_STATE_INIT("warn_urandom_randomness", HZ, 3);
static int ratelimit_disable __read_mostly;
module_param_named(ratelimit_disable, ratelimit_disable, int, 0644);
MODULE_PARM_DESC(ratelimit_disable, "Disable random ratelimit suppression");

/*
 * Returns whether or not the input pool has been seeded and thus guaranteed
 * to supply cryptographically secure random numbers. This applies to: the
 * /dev/urandom device, the get_random_bytes function, and the get_random_{u32,
 * ,u64,int,long} family of functions.
 *
 * Returns: true if the input pool has been seeded.
 *          false if the input pool has not been seeded.
 */
bool rng_is_initialized(void)
{
	return crng_ready();
}
EXPORT_SYMBOL(rng_is_initialized);

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
struct entropy_store;
struct entropy_store {
	/* read-only data: */
	const struct poolinfo *poolinfo;
	__u32 *pool;
	const char *name;
	struct entropy_store *pull;
	struct work_struct push_work;

	/* read-write data: */
	unsigned long last_pulled;
=======
static u32 input_pool_data[POOL_WORDS] __latent_entropy;

static struct {
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
	spinlock_t lock;
	unsigned short add_ptr;
	unsigned short input_rotate;
	int entropy_count;
	int entropy_total;
	unsigned int initialized:1;
	unsigned int last_data_init:1;
	__u8 last_data[EXTRACT_SIZE];
};

static ssize_t extract_entropy(struct entropy_store *r, void *buf,
			       size_t nbytes, int min, int rsvd);
static ssize_t _extract_entropy(struct entropy_store *r, void *buf,
				size_t nbytes, int fips);

static void crng_reseed(struct crng_state *crng, struct entropy_store *r);
static void push_to_pool(struct work_struct *work);
static __u32 input_pool_data[INPUT_POOL_WORDS] __latent_entropy;
static __u32 blocking_pool_data[OUTPUT_POOL_WORDS] __latent_entropy;

static struct entropy_store input_pool = {
	.poolinfo = &poolinfo_table[0],
	.name = "input",
	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
};

static struct entropy_store blocking_pool = {
	.poolinfo = &poolinfo_table[1],
	.name = "blocking",
	.pull = &input_pool,
	.lock = __SPIN_LOCK_UNLOCKED(blocking_pool.lock),
	.pool = blocking_pool_data,
	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
					push_to_pool),
};
=======
static struct {
	struct blake2s_state hash;
	spinlock_t lock;
	unsigned int entropy_count;
} input_pool = {
	.hash.h = { BLAKE2S_IV0 ^ (0x01010000 | BLAKE2S_HASH_SIZE),
		    BLAKE2S_IV1, BLAKE2S_IV2, BLAKE2S_IV3, BLAKE2S_IV4,
		    BLAKE2S_IV5, BLAKE2S_IV6, BLAKE2S_IV7 },
	.hash.outlen = BLAKE2S_HASH_SIZE,
	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
};

<<<<<<< HEAD
static bool extract_entropy(void *buf, size_t nbytes, int min);
static void _extract_entropy(void *buf, size_t nbytes);
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
=======
static void extract_entropy(void *buf, size_t nbytes);
<<<<<<< HEAD
>>>>>>> 62a2b4bd3ec9 (random: simplify entropy debiting)
=======
static bool drain_entropy(void *buf, size_t nbytes);
>>>>>>> 65419e900306 (random: introduce drain_entropy() helper to declutter crng_reseed())

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
static __u32 const twist_table[8] = {
=======
static void crng_reseed(struct crng_state *crng, bool use_input_pool);
=======
static void crng_reseed(struct crng_state *crng);
>>>>>>> 8c39bfd9db3c (random: remove use_input_pool parameter from crng_reseed())
=======
static void crng_reseed(void);
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
=======
/* Used by wait_for_random_bytes(), and considered an entropy collector, below. */
static void try_to_generate_entropy(void);
>>>>>>> 25061d366b70 (random: group initialization wait functions)

<<<<<<< HEAD
static const u32 twist_table[8] = {
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };

=======
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
/*
 * Wait for the input pool to be seeded and thus guaranteed to supply
 * cryptographically secure random numbers. This applies to: the /dev/urandom
 * device, the get_random_bytes function, and the get_random_{u32,u64,int,long}
 * family of functions. Using any of these functions without first calling
 * this function forfeits the guarantee of security.
 *
 * Returns: 0 if the input pool has been seeded.
 *          -ERESTARTSYS if the function was interrupted by a signal.
 */
<<<<<<< HEAD
<<<<<<< HEAD
static void _mix_pool_bytes(struct entropy_store *r, const void *in,
			    int nbytes)
=======
static void _mix_pool_bytes(const void *in, size_t nbytes)
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
{
<<<<<<< HEAD
	unsigned long i, tap1, tap2, tap3, tap4, tap5;
	int input_rotate;
	int wordmask = r->poolinfo->poolwords - 1;
	const char *bytes = in;
	__u32 w;

	tap1 = r->poolinfo->tap1;
	tap2 = r->poolinfo->tap2;
	tap3 = r->poolinfo->tap3;
	tap4 = r->poolinfo->tap4;
	tap5 = r->poolinfo->tap5;

	input_rotate = r->input_rotate;
	i = r->add_ptr;

	/* mix one byte at a time to simplify size handling and churn faster */
	while (nbytes--) {
		w = rol32(*bytes++, input_rotate);
		i = (i - 1) & wordmask;

		/* XOR in the various taps */
<<<<<<< HEAD
		w ^= r->pool[i];
		w ^= r->pool[(i + tap1) & wordmask];
		w ^= r->pool[(i + tap2) & wordmask];
		w ^= r->pool[(i + tap3) & wordmask];
		w ^= r->pool[(i + tap4) & wordmask];
		w ^= r->pool[(i + tap5) & wordmask];

		/* Mix the result back in with a twist */
		r->pool[i] = (w >> 3) ^ twist_table[w & 7];
=======
		w ^= input_pool_data[i];
		w ^= input_pool_data[(i + POOL_TAP1) & POOL_WORDMASK];
		w ^= input_pool_data[(i + POOL_TAP2) & POOL_WORDMASK];
		w ^= input_pool_data[(i + POOL_TAP3) & POOL_WORDMASK];
		w ^= input_pool_data[(i + POOL_TAP4) & POOL_WORDMASK];
		w ^= input_pool_data[(i + POOL_TAP5) & POOL_WORDMASK];

		/* Mix the result back in with a twist */
		input_pool_data[i] = (w >> 3) ^ twist_table[w & 7];
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)

		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		input_rotate = (input_rotate + (i ? 7 : 14)) & 31;
	}

	r->input_rotate = input_rotate;
	r->add_ptr = i;
=======
	blake2s_update(&input_pool.hash, in, nbytes);
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
}

<<<<<<< HEAD
static void __mix_pool_bytes(struct entropy_store *r, const void *in,
			     int nbytes)
{
	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
	_mix_pool_bytes(r, in, nbytes);
}

static void mix_pool_bytes(struct entropy_store *r, const void *in,
			   int nbytes)
=======
static void mix_pool_bytes(const void *in, size_t nbytes)
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
=======
int wait_for_random_bytes(void)
{
	if (likely(crng_ready()))
		return 0;

	do {
		int ret;
		ret = wait_event_interruptible_timeout(crng_init_wait, crng_ready(), HZ);
		if (ret)
			return ret > 0 ? 0 : ret;

		try_to_generate_entropy();
	} while (!crng_ready());

	return 0;
}
EXPORT_SYMBOL(wait_for_random_bytes);

/*
 * Add a callback function that will be invoked when the input
 * pool is initialised.
 *
 * returns: 0 if callback is successfully added
 *	    -EALREADY if pool is already initialised (callback not called)
 *	    -ENOENT if module for callback is not alive
 */
int add_random_ready_callback(struct random_ready_callback *rdy)
{
	struct module *owner;
	unsigned long flags;
	int err = -EALREADY;

	if (crng_ready())
		return err;

	owner = rdy->owner;
	if (!try_module_get(owner))
		return -ENOENT;

	spin_lock_irqsave(&random_ready_list_lock, flags);
	if (crng_ready())
		goto out;

	owner = NULL;

	list_add(&rdy->list, &random_ready_list);
	err = 0;

out:
	spin_unlock_irqrestore(&random_ready_list_lock, flags);

	module_put(owner);

	return err;
}
EXPORT_SYMBOL(add_random_ready_callback);

/*
 * Delete a previously registered readiness callback function.
 */
void del_random_ready_callback(struct random_ready_callback *rdy)
>>>>>>> 25061d366b70 (random: group initialization wait functions)
{
	unsigned long flags;
	struct module *owner = NULL;

<<<<<<< HEAD
<<<<<<< HEAD
	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
	spin_lock_irqsave(&r->lock, flags);
	_mix_pool_bytes(r, in, nbytes);
	spin_unlock_irqrestore(&r->lock, flags);
=======
	spin_lock_irqsave(&input_pool.lock, flags);
	_mix_pool_bytes(in, nbytes);
	spin_unlock_irqrestore(&input_pool.lock, flags);
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
}

struct fast_pool {
<<<<<<< HEAD
<<<<<<< HEAD
	__u32		pool[4];
	unsigned long	last;
	unsigned short	reg_idx;
	unsigned char	count;
=======
	u32 pool[4];
=======
	union {
		u32 pool32[4];
		u64 pool64[2];
	};
>>>>>>> e0a5363f51f5 (random: deobfuscate irq u32/u64 contributions)
	unsigned long last;
	u16 reg_idx;
	u8 count;
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
};

/*
 * This is a fast mixing routine used by the interrupt randomness
 * collector.  It's hardcoded for an 128 bit pool and assumes that any
 * locks that might be needed are taken by the caller.
 */
static void fast_mix(u32 pool[4])
{
<<<<<<< HEAD
	__u32 a = f->pool[0],	b = f->pool[1];
	__u32 c = f->pool[2],	d = f->pool[3];
=======
	u32 a = pool[0],	b = pool[1];
	u32 c = pool[2],	d = pool[3];
>>>>>>> e0a5363f51f5 (random: deobfuscate irq u32/u64 contributions)

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	pool[0] = a;  pool[1] = b;
	pool[2] = c;  pool[3] = d;
=======
	spin_lock_irqsave(&random_ready_list_lock, flags);
	if (!list_empty(&rdy->list)) {
		list_del_init(&rdy->list);
		owner = rdy->owner;
	}
	spin_unlock_irqrestore(&random_ready_list_lock, flags);

	module_put(owner);
>>>>>>> 25061d366b70 (random: group initialization wait functions)
}
EXPORT_SYMBOL(del_random_ready_callback);

static void process_random_ready_list(void)
{
	unsigned long flags;
	struct random_ready_callback *rdy, *tmp;

	spin_lock_irqsave(&random_ready_list_lock, flags);
	list_for_each_entry_safe(rdy, tmp, &random_ready_list, list) {
		struct module *owner = rdy->owner;

		list_del_init(&rdy->list);
		rdy->func(rdy);
		module_put(owner);
	}
	spin_unlock_irqrestore(&random_ready_list_lock, flags);
}

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
/*
 * Credit (or debit) the entropy store with n bits of entropy.
 * Use credit_entropy_bits_safe() if the value comes from userspace
 * or otherwise should be checked for extreme values.
 */
static void credit_entropy_bits(struct entropy_store *r, int nbits)
=======
static void credit_entropy_bits(int nbits)
>>>>>>> 6605171cd8cb (random: make credit_entropy_bits() always safe)
{
<<<<<<< HEAD
<<<<<<< HEAD
	int entropy_count, orig;
<<<<<<< HEAD
	const int pool_size = r->poolinfo->poolfracbits;
	int nfrac = nbits << ENTROPY_SHIFT;
=======
	int entropy_count, entropy_bits, orig;
=======
	int entropy_count, orig;
>>>>>>> 62a2b4bd3ec9 (random: simplify entropy debiting)
	int nfrac = nbits << POOL_ENTROPY_SHIFT;
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)

	/* Ensure that the multiplication can avoid being 64 bits wide. */
	BUILD_BUG_ON(2 * (POOL_ENTROPY_SHIFT + POOL_BITSHIFT) > 31);
=======
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
=======
static void credit_entropy_bits(size_t nbits)
{
	unsigned int entropy_count, orig, add;
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
=======
#define warn_unseeded_randomness(previous) \
	_warn_unseeded_randomness(__func__, (void *)_RET_IP_, (previous))

static void _warn_unseeded_randomness(const char *func_name, void *caller, void **previous)
{
#ifdef CONFIG_WARN_ALL_UNSEEDED_RANDOM
	const bool print_once = false;
#else
	static bool print_once __read_mostly;
#endif
>>>>>>> 25061d366b70 (random: group initialization wait functions)

	if (print_once || crng_ready() ||
	    (previous && (caller == READ_ONCE(*previous))))
		return;
<<<<<<< HEAD

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
retry:
	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
	if (nfrac < 0) {
		/* Debit */
		entropy_count += nfrac;
	} else {
		/*
		 * Credit: we have to account for the possibility of
		 * overwriting already present entropy.	 Even in the
		 * ideal case of pure Shannon entropy, new contributions
		 * approach the full value asymptotically:
		 *
		 * entropy <- entropy + (pool_size - entropy) *
		 *	(1 - exp(-add_entropy/pool_size))
		 *
		 * For add_entropy <= pool_size/2 then
		 * (1 - exp(-add_entropy/pool_size)) >=
		 *    (add_entropy/pool_size)*0.7869...
		 * so we can approximate the exponential with
		 * 3/4*add_entropy/pool_size and still be on the
		 * safe side by adding at most pool_size/2 at a time.
		 *
		 * The use of pool_size-2 in the while statement is to
		 * prevent rounding artifacts from making the loop
		 * arbitrarily long; this limits the loop to log2(pool_size)*2
		 * turns no matter how large nbits is.
		 */
		int pnfrac = nfrac;
<<<<<<< HEAD
		const int s = r->poolinfo->poolbitshift + ENTROPY_SHIFT + 2;
=======
		const int s = POOL_BITSHIFT + POOL_ENTROPY_SHIFT + 2;
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
		/* The +2 corresponds to the /4 in the denominator */

		do {
<<<<<<< HEAD
			unsigned int anfrac = min(pnfrac, pool_size/2);
			unsigned int add =
				((pool_size - entropy_count)*anfrac*3) >> s;

			entropy_count += add;
			pnfrac -= anfrac;
		} while (unlikely(entropy_count < pool_size-2 && pnfrac));
=======
			unsigned int anfrac = min(pnfrac, POOL_FRACBITS / 2);
			unsigned int add =
				((POOL_FRACBITS - entropy_count) * anfrac * 3) >> s;

			entropy_count += add;
			pnfrac -= anfrac;
		} while (unlikely(entropy_count < POOL_FRACBITS - 2 && pnfrac));
>>>>>>> 563845199476 (random: cleanup fractional entropy shift constants)
	}

	if (unlikely(entropy_count < 0)) {
		pr_warn("random: negative entropy/overflow: pool %s count %d\n",
			r->name, entropy_count);
		WARN_ON(1);
		entropy_count = 0;
	} else if (entropy_count > pool_size)
		entropy_count = pool_size;
	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
		goto retry;

<<<<<<< HEAD
	r->entropy_total += nbits;
	if (!r->initialized && r->entropy_total > 128) {
		r->initialized = 1;
		r->entropy_total = 0;
	}

	trace_credit_entropy_bits(r->name, nbits,
				  entropy_count >> ENTROPY_SHIFT,
				  r->entropy_total, _RET_IP_);

	if (r == &input_pool) {
		int entropy_bits = entropy_count >> ENTROPY_SHIFT;

		if (crng_init < 2 && entropy_bits >= 128) {
			crng_reseed(&primary_crng, r);
			entropy_bits = r->entropy_count >> ENTROPY_SHIFT;
		}

		/* should we wake readers? */
		if (entropy_bits >= random_read_wakeup_bits) {
			wake_up_interruptible(&random_read_wait);
			kill_fasync(&fasync, SIGIO, POLL_IN);
		}
		/* If the input pool is getting full, send some
		 * entropy to the blocking pool until it is 75% full.
		 */
		if (entropy_bits > random_write_wakeup_bits &&
		    r->initialized &&
		    r->entropy_total >= 2*random_read_wakeup_bits) {
			struct entropy_store *other = &blocking_pool;

			if (other->entropy_count <=
			    3 * other->poolinfo->poolfracbits / 4) {
				schedule_work(&other->push_work);
				r->entropy_total = 0;
			}
		}
	}
=======
	trace_credit_entropy_bits(nbits, entropy_count >> POOL_ENTROPY_SHIFT, _RET_IP_);

	if (crng_init < 2 && entropy_count >= POOL_MIN_FRACBITS)
=======
=======
	nbits = min(nbits, POOL_BITS);
=======
	add = min_t(size_t, nbits, POOL_BITS);
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

>>>>>>> 6605171cd8cb (random: make credit_entropy_bits() always safe)
	do {
		orig = READ_ONCE(input_pool.entropy_count);
		entropy_count = min_t(unsigned int, POOL_BITS, orig + add);
	} while (cmpxchg(&input_pool.entropy_count, orig, entropy_count) != orig);

	if (crng_init < 2 && entropy_count >= POOL_MIN_BITS)
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
		crng_reseed(&primary_crng, true);
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
=======
		crng_reseed(&primary_crng);
>>>>>>> 8c39bfd9db3c (random: remove use_input_pool parameter from crng_reseed())
=======
		crng_reseed();
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
}

<<<<<<< HEAD
static int credit_entropy_bits_safe(struct entropy_store *r, int nbits)
{
	const int nbits_max = r->poolinfo->poolwords * 32;

	if (nbits < 0)
		return -EINVAL;

	/* Cap the value to avoid overflows */
<<<<<<< HEAD
	nbits = min(nbits,  nbits_max);
=======
	nbits = min(nbits, POOL_BITS);
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)

	credit_entropy_bits(r, nbits);
	return 0;
}

=======
>>>>>>> 6605171cd8cb (random: make credit_entropy_bits() always safe)
=======
	WRITE_ONCE(*previous, caller);
#ifndef CONFIG_WARN_ALL_UNSEEDED_RANDOM
	print_once = true;
#endif
	if (__ratelimit(&unseeded_warning))
		printk_deferred(KERN_NOTICE "random: %s called from %pS with crng_init=%d\n",
				func_name, caller, crng_init);
}


>>>>>>> 25061d366b70 (random: group initialization wait functions)
/*********************************************************************
 *
 * Fast key erasure RNG, the "crng".
 *
 * These functions expand entropy from the entropy extractor into
 * long streams for external consumption using the "fast key erasure"
 * RNG described at <https://blog.cr.yp.to/20170723-random.html>.
 *
 * There are a few exported interfaces for use by other drivers:
 *
 *	void get_random_bytes(void *buf, size_t nbytes)
 *	u32 get_random_u32()
 *	u64 get_random_u64()
 *	unsigned int get_random_int()
 *	unsigned long get_random_long()
 *
 * These interfaces will return the requested number of random bytes
 * into the given buffer or as a return value. This is equivalent to
 * a read from /dev/urandom. The integer family of functions may be
 * higher performance for one-off random integers, because they do a
 * bit of buffering.
 *
 *********************************************************************/

enum {
	CRNG_RESEED_INTERVAL = 300 * HZ,
	CRNG_INIT_CNT_THRESH = 2 * CHACHA20_KEY_SIZE
};

static struct {
	u8 key[CHACHA20_KEY_SIZE] __aligned(__alignof__(long));
	unsigned long birth;
	unsigned long generation;
	spinlock_t lock;
} base_crng = {
	.lock = __SPIN_LOCK_UNLOCKED(base_crng.lock)
};

struct crng {
	u8 key[CHACHA20_KEY_SIZE];
	unsigned long generation;
};

static DEFINE_PER_CPU(struct crng, crngs) = {
	.generation = ULONG_MAX
};

/* Used by crng_reseed() to extract a new seed from the input pool. */
static bool drain_entropy(void *buf, size_t nbytes);

<<<<<<< HEAD
<<<<<<< HEAD
#ifdef CONFIG_NUMA
/*
 * Hack to deal with crazy userspace progams when they are all trying
 * to access /dev/urandom in parallel.  The programs are almost
 * certainly doing something terribly wrong, but we'll work around
 * their brain damage.
 */
static struct crng_state **crng_node_pool __read_mostly;
#endif

static void invalidate_batched_entropy(void);

static void crng_initialize(struct crng_state *crng)
{
<<<<<<< HEAD
	int		i;
	unsigned long	rv;
=======
	int i;
	bool arch_init = true;
	unsigned long rv;
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)

	memcpy(&crng->state[0], "expand 32-byte k", 16);
	if (crng == &primary_crng)
		_extract_entropy(&input_pool, &crng->state[4],
				 sizeof(__u32) * 12, 0);
	else
		_get_random_bytes(&crng->state[4], sizeof(__u32) * 12);
	for (i = 4; i < 16; i++) {
		if (!arch_get_random_seed_long(&rv) &&
		    !arch_get_random_long(&rv))
			rv = random_get_entropy();
		crng->state[i] ^= rv;
	}
<<<<<<< HEAD
=======

	return arch_init;
}
=======
static void invalidate_batched_entropy(void);

<<<<<<< HEAD
static bool trust_cpu __ro_after_init = IS_ENABLED(CONFIG_RANDOM_TRUST_CPU);
static int __init parse_trust_cpu(char *arg)
{
	return kstrtobool(arg, &trust_cpu);
}
early_param("random.trust_cpu", parse_trust_cpu);
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)

static bool __init crng_init_try_arch_early(void)
{
	int i;
	bool arch_init = true;
	unsigned long rv;

	for (i = 4; i < 16; i++) {
		if (!arch_get_random_seed_long_early(&rv) &&
		    !arch_get_random_long_early(&rv)) {
			rv = random_get_entropy();
			arch_init = false;
		}
		primary_crng.state[i] ^= rv;
	}

	return arch_init;
}

static void __init crng_initialize(void)
{
	extract_entropy(&primary_crng.state[4], sizeof(u32) * 12);
	if (crng_init_try_arch_early() && trust_cpu && crng_init < 2) {
		invalidate_batched_entropy();
		crng_init = 2;
		pr_notice("crng init done (trusting CPU's manufacturer)\n");
	}
<<<<<<< HEAD
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
	crng->init_time = jiffies - CRNG_RESEED_INTERVAL - 1;
=======
	primary_crng.init_time = jiffies - CRNG_RESEED_INTERVAL - 1;
>>>>>>> 7beef135045b (random: access primary_pool directly rather than through pointer)
}

<<<<<<< HEAD
<<<<<<< HEAD
#ifdef CONFIG_NUMA
=======
static void crng_finalize_init(void)
{
	if (!system_wq) {
		/* We can't call numa_crng_init until we have workqueues,
		 * so mark this for processing later. */
		crng_need_final_init = true;
		return;
	}

	invalidate_batched_entropy();
	numa_crng_init();
	crng_init = 2;
	crng_need_final_init = false;
	process_random_ready_list();
	wake_up_interruptible(&crng_init_wait);
	kill_fasync(&fasync, SIGIO, POLL_IN);
	pr_notice("crng init done\n");
	if (unseeded_warning.missed) {
		pr_notice("%d get_random_xx warning(s) missed due to ratelimiting\n",
			  unseeded_warning.missed);
		unseeded_warning.missed = 0;
	}
	if (urandom_warning.missed) {
		pr_notice("%d urandom warning(s) missed due to ratelimiting\n",
			  urandom_warning.missed);
		urandom_warning.missed = 0;
	}
}

>>>>>>> 7ad714b9dced (random: only call crng_finalize_init() for primary_crng)
static void do_numa_crng_init(struct work_struct *work)
{
	int i;
	struct crng_state *crng;
	struct crng_state **pool;

	pool = kcalloc(nr_node_ids, sizeof(*pool), GFP_KERNEL | __GFP_NOFAIL);
	for_each_online_node(i) {
		crng = kmalloc_node(sizeof(struct crng_state),
				    GFP_KERNEL | __GFP_NOFAIL, i);
		spin_lock_init(&crng->lock);
		crng_initialize(crng);
		pool[i] = crng;
	}
	/* pairs with READ_ONCE() in select_crng() */
	if (cmpxchg_release(&crng_node_pool, NULL, pool) != NULL) {
		for_each_node(i)
			kfree(pool[i]);
		kfree(pool);
	}
}

static DECLARE_WORK(numa_crng_init_work, do_numa_crng_init);

static void numa_crng_init(void)
{
	schedule_work(&numa_crng_init_work);
}

static struct crng_state *select_crng(void)
{
	struct crng_state **pool;
	int nid = numa_node_id();

	/* pairs with cmpxchg_release() in do_numa_crng_init() */
	pool = READ_ONCE(crng_node_pool);
	if (pool && pool[nid])
		return pool[nid];

	return &primary_crng;
}
#else
static void numa_crng_init(void) {}

static struct crng_state *select_crng(void)
{
	return &primary_crng;
}
#endif

=======
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
=======
>>>>>>> 13c423b6b1d3 (random: inline leaves of rand_initialize())
=======
>>>>>>> 15c96d9cb50d (random: tie batched entropy generation to base_crng generation)
/*
<<<<<<< HEAD
 * crng_fast_load() can be called by code in the interrupt service
 * path.  So we can't afford to dilly-dally.
 */
<<<<<<< HEAD
static int crng_fast_load(const char *cp, size_t len)
{
	unsigned long flags;
	char *p;
=======
static size_t crng_fast_load(const void *cp, size_t len)
{
	unsigned long flags;
	const u8 *src = (const u8 *)cp;
	size_t ret = 0;
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

	if (!spin_trylock_irqsave(&base_crng.lock, flags))
		return 0;
	if (crng_init != 0) {
		spin_unlock_irqrestore(&base_crng.lock, flags);
		return 0;
	}
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	p = (unsigned char *) &primary_crng.state[4];
=======
	p = (u8 *)&primary_crng.state[4];
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
	while (len > 0 && crng_init_cnt < CRNG_INIT_CNT_THRESH) {
		p[crng_init_cnt % CHACHA20_KEY_SIZE] ^= *cp;
		cp++; crng_init_cnt++; len--;
=======
	p = base_crng.key;
	while (len > 0 && crng_init_cnt < CRNG_INIT_CNT_THRESH) {
		p[crng_init_cnt % sizeof(base_crng.key)] ^= *cp;
		cp++; crng_init_cnt++; len--; ret++;
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
=======
	while (len > 0 && crng_init_cnt < CRNG_INIT_CNT_THRESH) {
		base_crng.key[crng_init_cnt % sizeof(base_crng.key)] ^= *src;
		src++; crng_init_cnt++; len--; ret++;
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
	}
	if (crng_init_cnt >= CRNG_INIT_CNT_THRESH) {
		++base_crng.generation;
		crng_init = 1;
<<<<<<< HEAD
		wake_up_interruptible(&crng_init_wait);
		pr_notice("random: fast init done\n");
	}
	return 1;
=======
	}
	spin_unlock_irqrestore(&base_crng.lock, flags);
	if (crng_init == 1)
		pr_notice("fast init done\n");
	return ret;
>>>>>>> 909f3974c58c (random: fix locking in crng_fast_load())
}

/*
 * crng_slow_load() is called by add_device_randomness, which has two
 * attributes.  (1) We can't trust the buffer passed to it is
 * guaranteed to be unpredictable (so it might not have any entropy at
 * all), and (2) it doesn't have the performance constraints of
 * crng_fast_load().
 *
 * So, we simply hash the contents in with the current key. Finally,
 * we do *not* advance crng_init_cnt since buffer we may get may be
 * something like a fixed DMI table (for example), which might very
 * well be unique to the machine, but is otherwise unvarying.
 */
<<<<<<< HEAD
static int crng_slow_load(const char *cp, size_t len)
=======
static void crng_slow_load(const void *cp, size_t len)
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
{
<<<<<<< HEAD
	unsigned long		flags;
	static unsigned char	lfsr = 1;
	unsigned char		tmp;
	unsigned		i, max = CHACHA20_KEY_SIZE;
	const char *		src_buf = cp;
	char *			dest_buf = (char *) &primary_crng.state[4];
=======
	unsigned long flags;
<<<<<<< HEAD
	static u8 lfsr = 1;
	u8 tmp;
	unsigned int i, max = sizeof(base_crng.key);
	const u8 *src_buf = cp;
<<<<<<< HEAD
	u8 *dest_buf = (u8 *)&primary_crng.state[4];
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
=======
	u8 *dest_buf = base_crng.key;
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
=======
	struct blake2s_state hash;

	blake2s_init(&hash, sizeof(base_crng.key));
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

	if (!spin_trylock_irqsave(&base_crng.lock, flags))
		return;
	if (crng_init != 0) {
		spin_unlock_irqrestore(&base_crng.lock, flags);
		return;
	}

	blake2s_update(&hash, base_crng.key, sizeof(base_crng.key));
	blake2s_update(&hash, cp, len);
	blake2s_final(&hash, base_crng.key);

	spin_unlock_irqrestore(&base_crng.lock, flags);
}

<<<<<<< HEAD
<<<<<<< HEAD
static void crng_reseed(struct crng_state *crng, struct entropy_store *r)
=======
static void crng_reseed(struct crng_state *crng)
>>>>>>> 8c39bfd9db3c (random: remove use_input_pool parameter from crng_reseed())
=======
=======
 * This extracts a new crng key from the input pool, but only if there is a
 * sufficient amount of entropy available, in order to mitigate bruteforcing
 * of newly added bits.
 */
>>>>>>> 25061d366b70 (random: group initialization wait functions)
static void crng_reseed(void)
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
{
	unsigned long flags;
<<<<<<< HEAD
<<<<<<< HEAD
	int i, entropy_count;
	union {
<<<<<<< HEAD
		__u8	block[CHACHA20_BLOCK_SIZE];
		__u32	key[8];
=======
		u8 block[CHACHA20_BLOCK_SIZE];
		u32 key[8];
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
	} buf;

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	if (r) {
		num = extract_entropy(r, &buf, 32, 16, 0);
		if (num == 0)
=======
	if (use_input_pool) {
<<<<<<< HEAD
		if (!extract_entropy(&buf, 32, 16))
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
			return;
=======
=======
	if (crng == &primary_crng) {
>>>>>>> 8c39bfd9db3c (random: remove use_input_pool parameter from crng_reseed())
		int entropy_count;
		do {
			entropy_count = READ_ONCE(input_pool.entropy_count);
			if (entropy_count < POOL_MIN_BITS)
				return;
		} while (cmpxchg(&input_pool.entropy_count, entropy_count, 0) != entropy_count);
		extract_entropy(buf.key, sizeof(buf.key));
<<<<<<< HEAD
		if (random_write_wakeup_bits) {
			wake_up_interruptible(&random_write_wait);
			kill_fasync(&fasync, SIGIO, POLL_OUT);
		}
>>>>>>> 62a2b4bd3ec9 (random: simplify entropy debiting)
=======
		wake_up_interruptible(&random_write_wait);
		kill_fasync(&fasync, SIGIO, POLL_OUT);
>>>>>>> f82262f273f1 (random: always wake up entropy writers after extraction)
	} else {
		_extract_crng(&primary_crng, buf.block);
		_crng_backtrack_protect(&primary_crng, buf.block,
					CHACHA20_KEY_SIZE);
	}
	spin_lock_irqsave(&crng->lock, flags);
	for (i = 0; i < 8; i++) {
		unsigned long rv;
		if (!arch_get_random_seed_long(&rv) &&
		    !arch_get_random_long(&rv))
			rv = random_get_entropy();
		crng->state[i + 4] ^= buf.key[i] ^ rv;
	}
	memzero_explicit(&buf, sizeof(buf));
	WRITE_ONCE(crng->init_time, jiffies);
	spin_unlock_irqrestore(&crng->lock, flags);
<<<<<<< HEAD
	if (crng == &primary_crng && crng_init < 2) {
		invalidate_batched_entropy();
		numa_crng_init();
		crng_init = 2;
		process_random_ready_list();
		wake_up_interruptible(&crng_init_wait);
		pr_notice("random: crng init done\n");
		if (unseeded_warning.missed) {
			pr_notice("random: %d get_random_xx warning(s) missed "
				  "due to ratelimiting\n",
=======
=======
	int entropy_count;
=======
>>>>>>> 65419e900306 (random: introduce drain_entropy() helper to declutter crng_reseed())
	unsigned long next_gen;
	u8 key[CHACHA20_KEY_SIZE];
	bool finalize_init = false;

<<<<<<< HEAD
	/*
	 * First we make sure we have POOL_MIN_BITS of entropy in the pool,
	 * and then we drain all of it. Only then can we extract a new key.
	 */
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
	do {
		entropy_count = READ_ONCE(input_pool.entropy_count);
		if (entropy_count < POOL_MIN_BITS)
			return;
	} while (cmpxchg(&input_pool.entropy_count, entropy_count, 0) != entropy_count);
	extract_entropy(key, sizeof(key));
	wake_up_interruptible(&random_write_wait);
	kill_fasync(&fasync, SIGIO, POLL_OUT);
=======
	/* Only reseed if we can, to prevent brute forcing a small amount of new bits. */
	if (!drain_entropy(key, sizeof(key)))
		return;
>>>>>>> 65419e900306 (random: introduce drain_entropy() helper to declutter crng_reseed())

	/*
	 * We copy the new key into the base_crng, overwriting the old one,
	 * and update the generation counter. We avoid hitting ULONG_MAX,
	 * because the per-cpu crngs are initialized to ULONG_MAX, so this
	 * forces new CPUs that come online to always initialize.
	 */
	spin_lock_irqsave(&base_crng.lock, flags);
	memcpy(base_crng.key, key, sizeof(base_crng.key));
	next_gen = base_crng.generation + 1;
	if (next_gen == ULONG_MAX)
		++next_gen;
	WRITE_ONCE(base_crng.generation, next_gen);
	WRITE_ONCE(base_crng.birth, jiffies);
	if (crng_init < 2) {
		crng_init = 2;
		finalize_init = true;
	}
	spin_unlock_irqrestore(&base_crng.lock, flags);
	memzero_explicit(key, sizeof(key));
	if (finalize_init) {
		process_random_ready_list();
		wake_up_interruptible(&crng_init_wait);
		kill_fasync(&fasync, SIGIO, POLL_IN);
		pr_notice("crng init done\n");
		if (unseeded_warning.missed) {
			pr_notice("%d get_random_xx warning(s) missed due to ratelimiting\n",
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
				  unseeded_warning.missed);
			unseeded_warning.missed = 0;
		}
		if (urandom_warning.missed) {
<<<<<<< HEAD
			pr_notice("random: %d urandom warning(s) missed "
				  "due to ratelimiting\n",
				  urandom_warning.missed);
			urandom_warning.missed = 0;
		}
	}
=======
	if (crng == &primary_crng && crng_init < 2)
		crng_finalize_init();
>>>>>>> 7ad714b9dced (random: only call crng_finalize_init() for primary_crng)
}

<<<<<<< HEAD
static void _extract_crng(struct crng_state *crng,
			  __u8 out[CHACHA20_BLOCK_SIZE])
=======
static void _extract_crng(struct crng_state *crng, u8 out[CHACHA20_BLOCK_SIZE])
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
{
	unsigned long v, flags, init_time;

	if (crng_ready()) {
		init_time = READ_ONCE(crng->init_time);
		if (time_after(READ_ONCE(crng_global_init_time), init_time) ||
		    time_after(jiffies, init_time + CRNG_RESEED_INTERVAL))
<<<<<<< HEAD
			crng_reseed(crng, crng == &primary_crng ?
				    &input_pool : NULL);
=======
			crng_reseed(crng);
>>>>>>> 8c39bfd9db3c (random: remove use_input_pool parameter from crng_reseed())
	}
	spin_lock_irqsave(&crng->lock, flags);
	if (arch_get_random_long(&v))
		crng->state[14] ^= v;
	chacha20_block(&crng->state[0], out);
	if (crng->state[12] == 0)
		crng->state[13]++;
	spin_unlock_irqrestore(&crng->lock, flags);
=======
			pr_notice("%d urandom warning(s) missed due to ratelimiting\n",
				  urandom_warning.missed);
			urandom_warning.missed = 0;
		}
	}
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
}

<<<<<<< HEAD
static void extract_crng(__u8 out[CHACHA20_BLOCK_SIZE])
=======
/*
 * This generates a ChaCha block using the provided key, and then
 * immediately overwites that key with half the block. It returns
 * the resultant ChaCha state to the user, along with the second
 * half of the block containing 32 bytes of random data that may
 * be used; random_data_len may not be greater than 32.
 */
static void crng_fast_key_erasure(u8 key[CHACHA20_KEY_SIZE],
				  u32 chacha_state[CHACHA20_BLOCK_SIZE / sizeof(u32)],
				  u8 *random_data, size_t random_data_len)
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
{
	u8 first_block[CHACHA20_BLOCK_SIZE];

	BUG_ON(random_data_len > 32);

	chacha_init_consts(chacha_state);
	memcpy(&chacha_state[4], key, CHACHA20_KEY_SIZE);
	memset(&chacha_state[12], 0, sizeof(u32) * 4);
	chacha20_block(chacha_state, first_block);

	memcpy(key, first_block, CHACHA20_KEY_SIZE);
	memcpy(random_data, first_block + CHACHA20_KEY_SIZE, random_data_len);
	memzero_explicit(first_block, sizeof(first_block));
}

/*
 * This function returns a ChaCha state that you may use for generating
 * random data. It also returns up to 32 bytes on its own of random data
 * that may be used; random_data_len may not be greater than 32.
 */
<<<<<<< HEAD
<<<<<<< HEAD
static void _crng_backtrack_protect(struct crng_state *crng,
				    __u8 tmp[CHACHA20_BLOCK_SIZE], int used)
=======
static void crng_backtrack_protect(u8 tmp[CHACHA20_BLOCK_SIZE], int used)
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
=======
static void crng_make_state(u32 chacha_state[CHACHA20_BLOCK_SIZE / sizeof(u32)],
			    u8 *random_data, size_t random_data_len)
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
{
<<<<<<< HEAD
	unsigned long	flags;
	__u32		*s, *d;
	int		i;
=======
	unsigned long flags;
<<<<<<< HEAD
	u32 *s, *d;
	int i;
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)

	used = round_up(used, sizeof(__u32));
	if (used + CHACHA20_KEY_SIZE > CHACHA20_BLOCK_SIZE) {
		extract_crng(tmp);
		used = 0;
	}
<<<<<<< HEAD
	spin_lock_irqsave(&crng->lock, flags);
<<<<<<< HEAD
	s = (__u32 *) &tmp[used];
=======
	s = (u32 *)&tmp[used];
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
	d = &crng->state[4];
	for (i = 0; i < 8; i++)
		*d++ ^= *s++;
	spin_unlock_irqrestore(&crng->lock, flags);
}

static void crng_backtrack_protect(__u8 tmp[CHACHA20_BLOCK_SIZE], int used)
{
	_crng_backtrack_protect(select_crng(), tmp, used);
=======
	spin_lock_irqsave(&primary_crng.lock, flags);
	s = (u32 *)&tmp[used];
	d = &primary_crng.state[4];
	for (i = 0; i < 8; i++)
		*d++ ^= *s++;
	spin_unlock_irqrestore(&primary_crng.lock, flags);
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
=======
	struct crng *crng;

	BUG_ON(random_data_len > 32);

	/*
	 * For the fast path, we check whether we're ready, unlocked first, and
	 * then re-check once locked later. In the case where we're really not
	 * ready, we do fast key erasure with the base_crng directly, because
	 * this is what crng_pre_init_inject() mutates during early init.
	 */
	if (unlikely(!crng_ready())) {
		bool ready;

		spin_lock_irqsave(&base_crng.lock, flags);
		ready = crng_ready();
		if (!ready)
			crng_fast_key_erasure(base_crng.key, chacha_state,
					      random_data, random_data_len);
		spin_unlock_irqrestore(&base_crng.lock, flags);
		if (!ready)
			return;
	}

	/*
	 * If the base_crng is more than 5 minutes old, we reseed, which
	 * in turn bumps the generation counter that we check below.
	 */
	if (unlikely(time_after(jiffies, READ_ONCE(base_crng.birth) + CRNG_RESEED_INTERVAL)))
		crng_reseed();

	local_irq_save(flags);
	crng = raw_cpu_ptr(&crngs);

	/*
	 * If our per-cpu crng is older than the base_crng, then it means
	 * somebody reseeded the base_crng. In that case, we do fast key
	 * erasure on the base_crng, and use its output as the new key
	 * for our per-cpu crng. This brings us up to date with base_crng.
	 */
	if (unlikely(crng->generation != READ_ONCE(base_crng.generation))) {
		spin_lock(&base_crng.lock);
		crng_fast_key_erasure(base_crng.key, chacha_state,
				      crng->key, sizeof(crng->key));
		crng->generation = base_crng.generation;
		spin_unlock(&base_crng.lock);
	}

	/*
	 * Finally, when we've made it this far, our per-cpu crng has an up
	 * to date key, and we can do fast key erasure with it to produce
	 * some random data and a ChaCha state for the caller. All other
	 * branches of this function are "unlikely", so most of the time we
	 * should wind up here immediately.
	 */
	crng_fast_key_erasure(crng->key, chacha_state, random_data, random_data_len);
	local_irq_restore(flags);
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
}

/*
 * This function is for crng_init == 0 only. It loads entropy directly
 * into the crng's key, without going through the input pool. It is,
 * generally speaking, not very safe, but we use this only at early
 * boot time when it's better to have something there rather than
 * nothing.
 *
 * There are two paths, a slow one and a fast one. The slow one
 * hashes the input along with the current key. The fast one simply
 * xors it in, and should only be used from interrupt context.
 *
 * If account is set, then the crng_init_cnt counter is incremented.
 * This shouldn't be set by functions like add_device_randomness(),
 * where we can't trust the buffer passed to it is guaranteed to be
 * unpredictable (so it might not have any entropy at all).
 *
 * Returns the number of bytes processed from input, which is bounded
 * by CRNG_INIT_CNT_THRESH if account is true.
 */
static size_t crng_pre_init_inject(const void *input, size_t len,
				   bool fast, bool account)
{
	static int crng_init_cnt = 0;
	unsigned long flags;

	if (fast) {
		if (!spin_trylock_irqsave(&base_crng.lock, flags))
			return 0;
	} else {
		spin_lock_irqsave(&base_crng.lock, flags);
	}

	if (crng_init != 0) {
		spin_unlock_irqrestore(&base_crng.lock, flags);
		return 0;
	}

	if (account)
		len = min_t(size_t, len, CRNG_INIT_CNT_THRESH - crng_init_cnt);

	if (fast) {
		const u8 *src = input;
		size_t i;

		for (i = 0; i < len; ++i)
			base_crng.key[(crng_init_cnt + i) %
				      sizeof(base_crng.key)] ^= src[i];
	} else {
		struct blake2s_state hash;

		blake2s_init(&hash, sizeof(base_crng.key));
		blake2s_update(&hash, base_crng.key, sizeof(base_crng.key));
		blake2s_update(&hash, input, len);
		blake2s_final(&hash, base_crng.key);
	}

	if (account) {
		crng_init_cnt += len;
		if (crng_init_cnt >= CRNG_INIT_CNT_THRESH) {
			++base_crng.generation;
			crng_init = 1;
		}
	}

	spin_unlock_irqrestore(&base_crng.lock, flags);

	if (crng_init == 1)
		pr_notice("fast init done\n");

	return len;
}

static void _get_random_bytes(void *buf, size_t nbytes)
{
	u32 chacha_state[CHACHA20_BLOCK_SIZE / sizeof(u32)];
	u8 tmp[CHACHA20_BLOCK_SIZE];
	size_t len;

	if (!nbytes)
		return;

	len = min_t(size_t, 32, nbytes);
	crng_make_state(chacha_state, buf, len);
	nbytes -= len;
	buf += len;

	while (nbytes) {
		if (nbytes < CHACHA20_BLOCK_SIZE) {
			chacha20_block(chacha_state, tmp);
			memcpy(buf, tmp, nbytes);
			memzero_explicit(tmp, sizeof(tmp));
			break;
		}

		chacha20_block(chacha_state, buf);
		if (unlikely(chacha_state[12] == 0))
			++chacha_state[13];
		nbytes -= CHACHA20_BLOCK_SIZE;
		buf += CHACHA20_BLOCK_SIZE;
	}

	memzero_explicit(chacha_state, sizeof(chacha_state));
}

/*
 * This function is the exported kernel interface.  It returns some
 * number of good random numbers, suitable for key generation, seeding
 * TCP sequence numbers, etc.  It does not rely on the hardware random
 * number generator.  For random bytes direct from the hardware RNG
 * (when available), use get_random_bytes_arch(). In order to ensure
 * that the randomness provided by this function is okay, the function
 * wait_for_random_bytes() should be called and return 0 at least once
 * at any point prior.
 */
void get_random_bytes(void *buf, size_t nbytes)
{
	static void *previous;

	warn_unseeded_randomness(&previous);
	_get_random_bytes(buf, nbytes);
}
EXPORT_SYMBOL(get_random_bytes);

static ssize_t get_random_bytes_user(void __user *buf, size_t nbytes)
{
<<<<<<< HEAD
	ssize_t ret = 0, i = CHACHA20_BLOCK_SIZE;
	__u8 tmp[CHACHA20_BLOCK_SIZE];
	int large_request = (nbytes > 256);
=======
	bool large_request = nbytes > 256;
	ssize_t ret = 0;
	size_t len;
	u32 chacha_state[CHACHA20_BLOCK_SIZE / sizeof(u32)];
	u8 output[CHACHA20_BLOCK_SIZE];

	if (!nbytes)
		return 0;

	len = min_t(size_t, 32, nbytes);
	crng_make_state(chacha_state, output, len);

	if (copy_to_user(buf, output, len))
		return -EFAULT;
	nbytes -= len;
	buf += len;
	ret += len;
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)

	while (nbytes) {
		if (large_request && need_resched()) {
			if (signal_pending(current))
				break;
			schedule();
		}

		chacha20_block(chacha_state, output);
		if (unlikely(chacha_state[12] == 0))
			++chacha_state[13];

		len = min_t(size_t, nbytes, CHACHA20_BLOCK_SIZE);
		if (copy_to_user(buf, output, len)) {
			ret = -EFAULT;
			break;
		}

		nbytes -= len;
		buf += len;
		ret += len;
	}

	memzero_explicit(chacha_state, sizeof(chacha_state));
	memzero_explicit(output, sizeof(output));
	return ret;
}

/*
 * Batched entropy returns random integers. The quality of the random
 * number is good as /dev/urandom. In order to ensure that the randomness
 * provided by this function is okay, the function wait_for_random_bytes()
 * should be called and return 0 at least once at any point prior.
 */
struct batched_entropy {
	union {
		/*
		 * We make this 1.5x a ChaCha block, so that we get the
		 * remaining 32 bytes from fast key erasure, plus one full
		 * block from the detached ChaCha state. We can increase
		 * the size of this later if needed so long as we keep the
		 * formula of (integer_blocks + 0.5) * CHACHA20_BLOCK_SIZE.
		 */
		u64 entropy_u64[CHACHA20_BLOCK_SIZE * 3 / (2 * sizeof(u64))];
		u32 entropy_u32[CHACHA20_BLOCK_SIZE * 3 / (2 * sizeof(u32))];
	};
	unsigned long generation;
	unsigned int position;
};


static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_u64) = {
	.position = UINT_MAX
};

u64 get_random_u64(void)
{
	u64 ret;
	unsigned long flags;
	struct batched_entropy *batch;
	static void *previous;
	unsigned long next_gen;

	warn_unseeded_randomness(&previous);

	local_irq_save(flags);
	batch = raw_cpu_ptr(&batched_entropy_u64);

	next_gen = READ_ONCE(base_crng.generation);
	if (batch->position >= ARRAY_SIZE(batch->entropy_u64) ||
	    next_gen != batch->generation) {
		_get_random_bytes(batch->entropy_u64, sizeof(batch->entropy_u64));
		batch->position = 0;
		batch->generation = next_gen;
	}

	ret = batch->entropy_u64[batch->position];
	batch->entropy_u64[batch->position] = 0;
	++batch->position;
	local_irq_restore(flags);
	return ret;
}
EXPORT_SYMBOL(get_random_u64);

static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_u32) = {
	.position = UINT_MAX
};

u32 get_random_u32(void)
{
	u32 ret;
	unsigned long flags;
	struct batched_entropy *batch;
	static void *previous;
	unsigned long next_gen;

	warn_unseeded_randomness(&previous);

	local_irq_save(flags);
	batch = raw_cpu_ptr(&batched_entropy_u32);

	next_gen = READ_ONCE(base_crng.generation);
	if (batch->position >= ARRAY_SIZE(batch->entropy_u32) ||
	    next_gen != batch->generation) {
		_get_random_bytes(batch->entropy_u32, sizeof(batch->entropy_u32));
		batch->position = 0;
		batch->generation = next_gen;
	}

	ret = batch->entropy_u32[batch->position];
	batch->entropy_u32[batch->position] = 0;
	++batch->position;
	local_irq_restore(flags);
	return ret;
}
EXPORT_SYMBOL(get_random_u32);

#ifdef CONFIG_SMP
/*
 * This function is called when the CPU is coming up, with entry
 * CPUHP_RANDOM_PREPARE, which comes before CPUHP_WORKQUEUE_PREP.
 */
int random_prepare_cpu(unsigned int cpu)
{
	/*
	 * When the cpu comes back online, immediately invalidate both
	 * the per-cpu crng and all batches, so that we serve fresh
	 * randomness.
	 */
	per_cpu_ptr(&crngs, cpu)->generation = ULONG_MAX;
	per_cpu_ptr(&batched_entropy_u32, cpu)->position = UINT_MAX;
	per_cpu_ptr(&batched_entropy_u64, cpu)->position = UINT_MAX;
	return 0;
}
#endif

/**
 * randomize_page - Generate a random, page aligned address
 * @start:	The smallest acceptable address the caller will take.
 * @range:	The size of the area, starting at @start, within which the
 *		random address must fall.
 *
 * If @start + @range would overflow, @range is capped.
 *
 * NOTE: Historical use of randomize_range, which this replaces, presumed that
 * @start was already page aligned.  We now align it regardless.
 *
 * Return: A page aligned address within [start, start + range).  On error,
 * @start is returned.
 */
unsigned long randomize_page(unsigned long start, unsigned long range)
{
	if (!PAGE_ALIGNED(start)) {
		range -= PAGE_ALIGN(start) - start;
		start = PAGE_ALIGN(start);
	}

	if (start > ULONG_MAX - range)
		range = ULONG_MAX - start;

	range >>= PAGE_SHIFT;

	if (range == 0)
		return start;

	return start + (get_random_long() % range << PAGE_SHIFT);
}

/*
 * This function will use the architecture-specific hardware random
 * number generator if it is available. It is not recommended for
 * use. Use get_random_bytes() instead. It returns the number of
 * bytes filled in.
 */
size_t __must_check get_random_bytes_arch(void *buf, size_t nbytes)
{
	size_t left = nbytes;
	u8 *p = buf;

	while (left) {
		unsigned long v;
		size_t chunk = min_t(size_t, left, sizeof(unsigned long));

		if (!arch_get_random_long(&v))
			break;

		memcpy(p, &v, chunk);
		p += chunk;
		left -= chunk;
	}

	return nbytes - left;
}
EXPORT_SYMBOL(get_random_bytes_arch);


/**********************************************************************
 *
 * Entropy accumulation and extraction routines.
 *
 * Callers may add entropy via:
 *
 *     static void mix_pool_bytes(const void *in, size_t nbytes)
 *
 * After which, if added entropy should be credited:
 *
 *     static void credit_entropy_bits(size_t nbits)
 *
 * Finally, extract entropy via these two, with the latter one
 * setting the entropy count to zero and extracting only if there
 * is POOL_MIN_BITS entropy credited prior:
 *
 *     static void extract_entropy(void *buf, size_t nbytes)
 *     static bool drain_entropy(void *buf, size_t nbytes)
 *
 **********************************************************************/

enum {
	POOL_BITS = BLAKE2S_HASH_SIZE * 8,
	POOL_MIN_BITS = POOL_BITS /* No point in settling for less. */
};

/* For notifying userspace should write into /dev/random. */
static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);

static struct {
	struct blake2s_state hash;
	spinlock_t lock;
	unsigned int entropy_count;
} input_pool = {
	.hash.h = { BLAKE2S_IV0 ^ (0x01010000 | BLAKE2S_HASH_SIZE),
		    BLAKE2S_IV1, BLAKE2S_IV2, BLAKE2S_IV3, BLAKE2S_IV4,
		    BLAKE2S_IV5, BLAKE2S_IV6, BLAKE2S_IV7 },
	.hash.outlen = BLAKE2S_HASH_SIZE,
	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
};

static void _mix_pool_bytes(const void *in, size_t nbytes)
{
	blake2s_update(&input_pool.hash, in, nbytes);
}

/*
 * This function adds bytes into the entropy "pool".  It does not
 * update the entropy estimate.  The caller should call
 * credit_entropy_bits if this is appropriate.
 */
static void mix_pool_bytes(const void *in, size_t nbytes)
{
	unsigned long flags;

	spin_lock_irqsave(&input_pool.lock, flags);
	_mix_pool_bytes(in, nbytes);
	spin_unlock_irqrestore(&input_pool.lock, flags);
}

static void credit_entropy_bits(size_t nbits)
{
	unsigned int entropy_count, orig, add;

	if (!nbits)
		return;

	add = min_t(size_t, nbits, POOL_BITS);

	do {
		orig = READ_ONCE(input_pool.entropy_count);
		entropy_count = min_t(unsigned int, POOL_BITS, orig + add);
	} while (cmpxchg(&input_pool.entropy_count, orig, entropy_count) != orig);

	if (crng_init < 2 && entropy_count >= POOL_MIN_BITS)
		crng_reseed();
}

/*
 * This is an HKDF-like construction for using the hashed collected entropy
 * as a PRF key, that's then expanded block-by-block.
 */
static void extract_entropy(void *buf, size_t nbytes)
{
	unsigned long flags;
	u8 seed[BLAKE2S_HASH_SIZE], next_key[BLAKE2S_HASH_SIZE];
	struct {
		unsigned long rdseed[32 / sizeof(long)];
		size_t counter;
	} block;
	size_t i;

	for (i = 0; i < ARRAY_SIZE(block.rdseed); ++i) {
		if (!arch_get_random_seed_long(&block.rdseed[i]) &&
		    !arch_get_random_long(&block.rdseed[i]))
			block.rdseed[i] = random_get_entropy();
	}

	spin_lock_irqsave(&input_pool.lock, flags);

	/* seed = HASHPRF(last_key, entropy_input) */
	blake2s_final(&input_pool.hash, seed);

	/* next_key = HASHPRF(seed, RDSEED || 0) */
	block.counter = 0;
	blake2s(next_key, (u8 *)&block, seed, sizeof(next_key), sizeof(block), sizeof(seed));
	blake2s_init_key(&input_pool.hash, BLAKE2S_HASH_SIZE, next_key, sizeof(next_key));

	spin_unlock_irqrestore(&input_pool.lock, flags);
	memzero_explicit(next_key, sizeof(next_key));

	while (nbytes) {
		i = min_t(size_t, nbytes, BLAKE2S_HASH_SIZE);
		/* output = HASHPRF(seed, RDSEED || ++counter) */
		++block.counter;
		blake2s(buf, (u8 *)&block, seed, i, sizeof(block), sizeof(seed));
		nbytes -= i;
		buf += i;
	}

	memzero_explicit(seed, sizeof(seed));
	memzero_explicit(&block, sizeof(block));
}

/*
 * First we make sure we have POOL_MIN_BITS of entropy in the pool, and then we
 * set the entropy count to zero (but don't actually touch any data). Only then
 * can we extract a new key with extract_entropy().
 */
static bool drain_entropy(void *buf, size_t nbytes)
{
	unsigned int entropy_count;
	do {
		entropy_count = READ_ONCE(input_pool.entropy_count);
		if (entropy_count < POOL_MIN_BITS)
			return false;
	} while (cmpxchg(&input_pool.entropy_count, entropy_count, 0) != entropy_count);
	extract_entropy(buf, nbytes);
	wake_up_interruptible(&random_write_wait);
	kill_fasync(&fasync, SIGIO, POLL_OUT);
	return true;
}


/**********************************************************************
 *
 * Entropy collection routines.
 *
 * The following exported functions are used for pushing entropy into
 * the above entropy accumulation routines:
 *
 *	void add_device_randomness(const void *buf, size_t size);
 *	void add_input_randomness(unsigned int type, unsigned int code,
 *	                          unsigned int value);
 *	void add_disk_randomness(struct gendisk *disk);
 *	void add_hwgenerator_randomness(const void *buffer, size_t count,
 *					size_t entropy);
 *	void add_bootloader_randomness(const void *buf, size_t size);
 *	void add_interrupt_randomness(int irq);
 *
 * add_device_randomness() adds data to the input pool that
 * is likely to differ between two devices (or possibly even per boot).
 * This would be things like MAC addresses or serial numbers, or the
 * read-out of the RTC. This does *not* credit any actual entropy to
 * the pool, but it initializes the pool to different values for devices
 * that might otherwise be identical and have very little entropy
 * available to them (particularly common in the embedded world).
 *
 * add_input_randomness() uses the input layer interrupt timing, as well
 * as the event type information from the hardware.
 *
 * add_disk_randomness() uses what amounts to the seek time of block
 * layer request events, on a per-disk_devt basis, as input to the
 * entropy pool. Note that high-speed solid state drives with very low
 * seek times do not make for good sources of entropy, as their seek
 * times are usually fairly consistent.
 *
 * The above two routines try to estimate how many bits of entropy
 * to credit. They do this by keeping track of the first and second
 * order deltas of the event timings.
 *
 * add_hwgenerator_randomness() is for true hardware RNGs, and will credit
 * entropy as specified by the caller. If the entropy pool is full it will
 * block until more entropy is needed.
 *
 * add_bootloader_randomness() is the same as add_hwgenerator_randomness() or
 * add_device_randomness(), depending on whether or not the configuration
 * option CONFIG_RANDOM_TRUST_BOOTLOADER is set.
 *
 * add_interrupt_randomness() uses the interrupt timing as random
 * inputs to the entropy pool. Using the cycle counters and the irq source
 * as inputs, it feeds the input pool roughly once a second or after 64
 * interrupts, crediting 1 bit of entropy for whichever comes first.
 *
 **********************************************************************/

static bool trust_cpu __ro_after_init = IS_ENABLED(CONFIG_RANDOM_TRUST_CPU);
static int __init parse_trust_cpu(char *arg)
{
	return kstrtobool(arg, &trust_cpu);
}
early_param("random.trust_cpu", parse_trust_cpu);

/*
 * The first collection of entropy occurs at system boot while interrupts
 * are still turned off. Here we push in RDSEED, a timestamp, and utsname().
 * Depending on the above configuration knob, RDSEED may be considered
 * sufficient for initialization. Note that much earlier setup may already
 * have pushed entropy into the input pool by the time we get here.
 */
int __init rand_initialize(void)
{
	size_t i;
	ktime_t now = ktime_get_real();
	bool arch_init = true;
	unsigned long rv;

	for (i = 0; i < BLAKE2S_BLOCK_SIZE; i += sizeof(rv)) {
		if (!arch_get_random_seed_long_early(&rv) &&
		    !arch_get_random_long_early(&rv)) {
			rv = random_get_entropy();
			arch_init = false;
		}
		_mix_pool_bytes(&rv, sizeof(rv));
	}
	_mix_pool_bytes(&now, sizeof(now));
	_mix_pool_bytes(utsname(), sizeof(*(utsname())));

	extract_entropy(base_crng.key, sizeof(base_crng.key));
	++base_crng.generation;

	if (arch_init && trust_cpu && crng_init < 2) {
		crng_init = 2;
		pr_notice("crng init done (trusting CPU's manufacturer)\n");
	}

	if (ratelimit_disable) {
		urandom_warning.interval = 0;
		unseeded_warning.interval = 0;
	}
	return 0;
}

/* There is one of these per entropy source */
struct timer_rand_state {
	cycles_t last_time;
	long last_delta, last_delta2;
	unsigned dont_count_entropy:1;
};

/*
 * Add device- or boot-specific data to the input pool to help
 * initialize it.
 *
 * None of this adds any entropy; it is meant to avoid the problem of
 * the entropy pool having similar initial state across largely
 * identical devices.
 */
void add_device_randomness(const void *buf, size_t size)
{
	unsigned long time = random_get_entropy() ^ jiffies;
	unsigned long flags;

	if (crng_init == 0 && size)
		crng_pre_init_inject(buf, size, false, false);

	spin_lock_irqsave(&input_pool.lock, flags);
	_mix_pool_bytes(&input_pool, buf, size);
	_mix_pool_bytes(&input_pool, &time, sizeof(time));
	spin_unlock_irqrestore(&input_pool.lock, flags);
}
EXPORT_SYMBOL(add_device_randomness);

/*
 * This function adds entropy to the entropy "pool" by using timing
 * delays.  It uses the timer_rand_state structure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "num" is also added to the pool - it should somehow describe
 * the type of event which just happened.  This is currently 0-255 for
 * keyboard scan codes, and 256 upwards for interrupts.
 *
 */
static void add_timer_randomness(struct timer_rand_state *state, unsigned int num)
{
	struct entropy_store	*r;
	struct {
		long jiffies;
		unsigned cycles;
		unsigned num;
	} sample;
	long delta, delta2, delta3;

	preempt_disable();

	sample.jiffies = jiffies;
	sample.cycles = random_get_entropy();
	sample.num = num;
	r = &input_pool;
	mix_pool_bytes(r, &sample, sizeof(sample));

	/*
	 * Calculate number of bits of randomness we probably added.
	 * We take into account the first, second and third-order deltas
	 * in order to make our estimate.
	 */

	if (!state->dont_count_entropy) {
		delta = sample.jiffies - state->last_time;
		state->last_time = sample.jiffies;

		delta2 = delta - state->last_delta;
		state->last_delta = delta;

		delta3 = delta2 - state->last_delta2;
		state->last_delta2 = delta2;

<<<<<<< HEAD
		if (delta < 0)
			delta = -delta;
		if (delta2 < 0)
			delta2 = -delta2;
		if (delta3 < 0)
			delta3 = -delta3;
		if (delta > delta2)
			delta = delta2;
		if (delta > delta3)
			delta = delta3;

		/*
		 * delta is now minimum absolute delta.
		 * Round down by 1 bit on general principles,
		 * and limit entropy entimate to 12 bits.
		 */
		credit_entropy_bits(r, min_t(int, fls(delta>>1), 11));
	}
	preempt_enable();
=======
	/*
	 * delta is now minimum absolute delta.
	 * Round down by 1 bit on general principles,
	 * and limit entropy estimate to 12 bits.
	 */
<<<<<<< HEAD
	credit_entropy_bits(min_t(int, fls(delta >> 1), 11));
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
=======
	credit_entropy_bits(min_t(unsigned int, fls(delta >> 1), 11));
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
}

void add_input_randomness(unsigned int type, unsigned int code,
			  unsigned int value)
{
	static unsigned char last_value;
	static struct timer_rand_state input_timer_state = { INITIAL_JIFFIES };

	/* Ignore autorepeat and the like. */
	if (value == last_value)
		return;

	last_value = value;
	add_timer_randomness(&input_timer_state,
			     (type << 4) ^ code ^ (code >> 4) ^ value);
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	trace_add_input_randomness(ENTROPY_BITS(&input_pool));
=======
	trace_add_input_randomness(POOL_ENTROPY_BITS());
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
=======
	trace_add_input_randomness(input_pool.entropy_count);
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
=======
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
}
EXPORT_SYMBOL_GPL(add_input_randomness);

#ifdef CONFIG_BLOCK
void add_disk_randomness(struct gendisk *disk)
{
	if (!disk || !disk->random)
		return;
	/* First major is 1, so we get >= 0x200 here. */
	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
}
EXPORT_SYMBOL_GPL(add_disk_randomness);

void rand_initialize_disk(struct gendisk *disk)
{
	struct timer_rand_state *state;

	/*
	 * If kzalloc returns null, we just won't use that entropy
	 * source.
	 */
	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
	if (state) {
		state->last_time = INITIAL_JIFFIES;
		disk->random = state;
	}
}
#endif

/*
 * Interface for in-kernel drivers of true hardware RNGs.
 * Those devices may produce endless random bits and will be throttled
 * when our pool is full.
 */
void add_hwgenerator_randomness(const void *buffer, size_t count,
				size_t entropy)
{
	if (unlikely(crng_init == 0)) {
		size_t ret = crng_pre_init_inject(buffer, count, false, true);
		mix_pool_bytes(buffer, ret);
		count -= ret;
		buffer += ret;
		if (!count || crng_init == 0)
			return;
	}

	/*
	 * Throttle writing if we're above the trickle threshold.
	 * We'll be woken up again once below POOL_MIN_BITS, when
	 * the calling thread is about to terminate, or once
	 * CRNG_RESEED_INTERVAL has elapsed.
	 */
	wait_event_interruptible_timeout(random_write_wait,
			!system_wq || kthread_should_stop() ||
			input_pool.entropy_count < POOL_MIN_BITS,
			CRNG_RESEED_INTERVAL);
	mix_pool_bytes(buffer, count);
	credit_entropy_bits(entropy);
}
EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);

/*
 * Handle random seed passed by bootloader.
 * If the seed is trustworthy, it would be regarded as hardware RNGs. Otherwise
 * it would be regarded as device data.
 * The decision is controlled by CONFIG_RANDOM_TRUST_BOOTLOADER.
 */
void add_bootloader_randomness(const void *buf, size_t size)
{
	if (IS_ENABLED(CONFIG_RANDOM_TRUST_BOOTLOADER))
		add_hwgenerator_randomness(buf, size, size * 8);
	else
		add_device_randomness(buf, size);
}
EXPORT_SYMBOL_GPL(add_bootloader_randomness);

struct fast_pool {
	union {
		u32 pool32[4];
		u64 pool64[2];
	};
	struct work_struct mix;
	unsigned long last;
	unsigned int count;
	u16 reg_idx;
};

/*
 * This is a fast mixing routine used by the interrupt randomness
 * collector. It's hardcoded for an 128 bit pool and assumes that any
 * locks that might be needed are taken by the caller.
 */
static void fast_mix(u32 pool[4])
{
	u32 a = pool[0],	b = pool[1];
	u32 c = pool[2],	d = pool[3];

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	pool[0] = a;  pool[1] = b;
	pool[2] = c;  pool[3] = d;
}

static DEFINE_PER_CPU(struct fast_pool, irq_randomness);

<<<<<<< HEAD
<<<<<<< HEAD
#ifdef ADD_INTERRUPT_BENCH
static unsigned long avg_cycles, avg_deviation;

#define AVG_SHIFT 8 /* Exponential average factor k=1/256 */
#define FIXED_1_2 (1 << (AVG_SHIFT - 1))

static void add_interrupt_bench(cycles_t start)
=======
#ifdef CONFIG_SMP
/*
 * This function is called when the CPU has just come online, with
 * entry CPUHP_AP_RANDOM_ONLINE, just after CPUHP_AP_WORKQUEUE_ONLINE.
 */
int random_online_cpu(unsigned int cpu)
{
	/*
	 * During CPU shutdown and before CPU onlining, add_interrupt_
	 * randomness() may schedule mix_interrupt_randomness(), and
	 * set the MIX_INFLIGHT flag. However, because the worker can
	 * be scheduled on a different CPU during this period, that
	 * flag will never be cleared. For that reason, we zero out
	 * the flag here, which runs just after workqueues are onlined
	 * for the CPU again. This also has the effect of setting the
	 * irq randomness count to zero so that new accumulated irqs
	 * are fresh.
	 */
	per_cpu_ptr(&irq_randomness, cpu)->count = 0;
	return 0;
}
#endif

<<<<<<< HEAD
static u32 get_reg(struct fast_pool *f, struct pt_regs *regs)
>>>>>>> 40b5b4b62203 (random: clear fast pool, crng, and batches in cpuhp bring up)
{
	long delta = random_get_entropy() - start;

	/* Use a weighted moving average */
	delta = delta - ((avg_cycles + FIXED_1_2) >> AVG_SHIFT);
	avg_cycles += delta;
	/* And average deviation */
	delta = abs(delta) - ((avg_deviation + FIXED_1_2) >> AVG_SHIFT);
	avg_deviation += delta;
}
#else
#define add_interrupt_bench(x)
#endif

static __u32 get_reg(struct fast_pool *f, struct pt_regs *regs)
=======
static u32 get_reg(struct fast_pool *f, struct pt_regs *regs)
>>>>>>> f8a196cf4751 (random: remove ifdef'd out interrupt bench)
{
<<<<<<< HEAD
	__u32 *ptr = (__u32 *) regs;
=======
	u32 *ptr = (u32 *)regs;
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
=======
static unsigned long get_reg(struct fast_pool *f, struct pt_regs *regs)
{
	unsigned long *ptr = (unsigned long *)regs;
>>>>>>> 23fc6dcd2935 (random: round-robin registers as ulong, not u32)
	unsigned int idx;

	if (regs == NULL)
		return 0;
	idx = READ_ONCE(f->reg_idx);
<<<<<<< HEAD
	if (idx >= sizeof(struct pt_regs) / sizeof(__u32))
=======
	if (idx >= sizeof(struct pt_regs) / sizeof(unsigned long))
>>>>>>> 23fc6dcd2935 (random: round-robin registers as ulong, not u32)
		idx = 0;
	ptr += idx++;
	WRITE_ONCE(f->reg_idx, idx);
	return *ptr;
}

<<<<<<< HEAD
void add_interrupt_randomness(int irq, int irq_flags)
{
<<<<<<< HEAD
	struct entropy_store	*r;
	struct fast_pool	*fast_pool = this_cpu_ptr(&irq_randomness);
	struct pt_regs		*regs = get_irq_regs();
	unsigned long		now = jiffies;
	cycles_t		cycles = random_get_entropy();
	__u32			c_high, j_high;
	__u64			ip;
	unsigned long		seed;
	int			credit = 0;
=======
=======
static void mix_interrupt_randomness(struct work_struct *work)
{
	struct fast_pool *fast_pool = container_of(work, struct fast_pool, mix);
	u32 pool[4];

	/* Check to see if we're running on the wrong CPU due to hotplug. */
	local_irq_disable();
	if (fast_pool != this_cpu_ptr(&irq_randomness)) {
		local_irq_enable();
		return;
	}

	/*
	 * Copy the pool to the stack so that the mixer always has a
	 * consistent view, before we reenable irqs again.
	 */
	memcpy(pool, fast_pool->pool32, sizeof(pool));
	fast_pool->count = 0;
	fast_pool->last = jiffies;
	local_irq_enable();

	mix_pool_bytes(pool, sizeof(pool));
	credit_entropy_bits(1);
	memzero_explicit(pool, sizeof(pool));
}

void add_interrupt_randomness(int irq)
{
	enum { MIX_INFLIGHT = 1U << 31 };
>>>>>>> 80adfc1fa691 (random: defer fast pool mixing to worker)
	struct fast_pool *fast_pool = this_cpu_ptr(&irq_randomness);
	struct pt_regs *regs = get_irq_regs();
	unsigned long now = jiffies;
	cycles_t cycles = random_get_entropy();
<<<<<<< HEAD
<<<<<<< HEAD
	u32 c_high, j_high;
	u64 ip;
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
=======
>>>>>>> e0a5363f51f5 (random: deobfuscate irq u32/u64 contributions)
=======
	unsigned int new_count;
>>>>>>> 80adfc1fa691 (random: defer fast pool mixing to worker)

	if (cycles == 0)
		cycles = get_reg(fast_pool, regs);

	if (sizeof(cycles) == 8)
		fast_pool->pool64[0] ^= cycles ^ rol64(now, 32) ^ irq;
	else {
		fast_pool->pool32[0] ^= cycles ^ irq;
		fast_pool->pool32[1] ^= now;
	}

	if (sizeof(unsigned long) == 8)
		fast_pool->pool64[1] ^= regs ? instruction_pointer(regs) : _RET_IP_;
	else {
		fast_pool->pool32[2] ^= regs ? instruction_pointer(regs) : _RET_IP_;
		fast_pool->pool32[3] ^= get_reg(fast_pool, regs);
	}

	fast_mix(fast_pool->pool32);
	new_count = ++fast_pool->count;

	if (unlikely(crng_init == 0)) {
<<<<<<< HEAD
<<<<<<< HEAD
		if ((fast_pool->count >= 64) &&
		    crng_fast_load((char *) fast_pool->pool,
				   sizeof(fast_pool->pool))) {
=======
		if (fast_pool->count >= 64 &&
<<<<<<< HEAD
		    crng_fast_load(fast_pool->pool, sizeof(fast_pool->pool)) > 0) {
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
=======
		    crng_fast_load(fast_pool->pool32, sizeof(fast_pool->pool32)) > 0) {
>>>>>>> e0a5363f51f5 (random: deobfuscate irq u32/u64 contributions)
			fast_pool->count = 0;
=======
		if (new_count >= 64 &&
		    crng_pre_init_inject(fast_pool->pool32, sizeof(fast_pool->pool32),
					 true, true) > 0) {
<<<<<<< HEAD
			atomic_set(&fast_pool->count, 0);
>>>>>>> 80adfc1fa691 (random: defer fast pool mixing to worker)
=======
			fast_pool->count = 0;
>>>>>>> 40b5b4b62203 (random: clear fast pool, crng, and batches in cpuhp bring up)
			fast_pool->last = now;
			if (spin_trylock(&input_pool.lock)) {
				_mix_pool_bytes(&fast_pool->pool32, sizeof(fast_pool->pool32));
				spin_unlock(&input_pool.lock);
			}
		}
		return;
	}

	if (new_count & MIX_INFLIGHT)
		return;

<<<<<<< HEAD
	r = &input_pool;
	if (!spin_trylock(&r->lock))
		return;

	fast_pool->last = now;
<<<<<<< HEAD
<<<<<<< HEAD
	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));

	/*
	 * If we have architectural seed generator, produce a seed and
	 * add it to the pool.  For the sake of paranoia don't let the
	 * architectural seed generator dominate the input from the
	 * interrupt noise.
	 */
	if (arch_get_random_seed_long(&seed)) {
		__mix_pool_bytes(r, &seed, sizeof(seed));
		credit = 1;
	}
	spin_unlock(&r->lock);
=======
	_mix_pool_bytes(&fast_pool->pool, sizeof(fast_pool->pool));
=======
	_mix_pool_bytes(&fast_pool->pool32, sizeof(fast_pool->pool32));
>>>>>>> e0a5363f51f5 (random: deobfuscate irq u32/u64 contributions)
	spin_unlock(&input_pool.lock);
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

	fast_pool->count = 0;

<<<<<<< HEAD
	/* award one bit for the contents of the fast pool */
	credit_entropy_bits(r, credit + 1);
}
EXPORT_SYMBOL_GPL(add_interrupt_randomness);

#ifdef CONFIG_BLOCK
void add_disk_randomness(struct gendisk *disk)
{
	if (!disk || !disk->random)
		return;
	/* first major is 1, so we get >= 0x200 here */
	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	trace_add_disk_randomness(disk_devt(disk), ENTROPY_BITS(&input_pool));
=======
	trace_add_disk_randomness(disk_devt(disk), POOL_ENTROPY_BITS());
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
=======
	trace_add_disk_randomness(disk_devt(disk), input_pool.entropy_count);
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
=======
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
}
EXPORT_SYMBOL_GPL(add_disk_randomness);
#endif

<<<<<<< HEAD
/*********************************************************************
 *
 * Entropy extraction routines
 *
 *********************************************************************/

/*
<<<<<<< HEAD
 * This utility inline function is responsible for transferring entropy
 * from the primary pool to the secondary extraction pool. We make
 * sure we pull enough for a 'catastrophic reseed'.
 */
static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes);
static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
{
	if (!r->pull ||
	    r->entropy_count >= (nbytes << (ENTROPY_SHIFT + 3)) ||
	    r->entropy_count > r->poolinfo->poolfracbits)
		return;

	_xfer_secondary_pool(r, nbytes);
}

static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
{
	__u32	tmp[OUTPUT_POOL_WORDS];

	int bytes = nbytes;

	/* pull at least as much as a wakeup */
	bytes = max_t(int, bytes, random_read_wakeup_bits / 8);
	/* but never more than the buffer size */
	bytes = min_t(int, bytes, sizeof(tmp));

	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
	bytes = extract_entropy(r->pull, tmp, bytes,
				random_read_wakeup_bits / 8, 0);
	mix_pool_bytes(r, tmp, bytes);
	credit_entropy_bits(r, bytes*8);
}

/*
 * Used as a workqueue function so that when the input pool is getting
 * full, we can "spill over" some entropy to the output pools.  That
 * way the output pools can store some of the excess entropy instead
 * of letting it go to waste.
 */
static void push_to_pool(struct work_struct *work)
{
	struct entropy_store *r = container_of(work, struct entropy_store,
					      push_work);
	BUG_ON(!r);
	_xfer_secondary_pool(r, random_read_wakeup_bits/8);
	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
			   r->pull->entropy_count >> ENTROPY_SHIFT);
}

/*
 * This function decides how many bytes to actually take from the
 * given pool, and also debits the entropy count accordingly.
 */
static size_t account(struct entropy_store *r, size_t nbytes, int min,
		      int reserved)
{
	int entropy_count, orig;
	size_t ibytes, nfrac;

	BUG_ON(r->entropy_count > r->poolinfo->poolfracbits);

	/* Can we pull enough? */
retry:
<<<<<<< HEAD
	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
	ibytes = nbytes;
	/* never pull more than available */
	have_bytes = entropy_count >> (POOL_ENTROPY_SHIFT + 3);

	if ((have_bytes -= reserved) < 0)
		have_bytes = 0;
	ibytes = min_t(size_t, ibytes, have_bytes);
	if (ibytes < min)
		ibytes = 0;

	if (unlikely(entropy_count < 0)) {
		pr_warn("random: negative entropy count: pool %s count %d\n",
			r->name, entropy_count);
		WARN_ON(1);
=======
	entropy_count = orig = READ_ONCE(input_pool.entropy_count);
	if (WARN_ON(entropy_count < 0)) {
		pr_warn("negative entropy count: count %d\n", entropy_count);
>>>>>>> 5c539eee39b2 (random: simplify arithmetic function flow in account())
		entropy_count = 0;
	}

	/* never pull more than available */
	ibytes = min_t(size_t, nbytes, entropy_count >> (POOL_ENTROPY_SHIFT + 3));
	if (ibytes < min)
		ibytes = 0;
	nfrac = ibytes << (POOL_ENTROPY_SHIFT + 3);
	if ((size_t)entropy_count > nfrac)
		entropy_count -= nfrac;
	else
		entropy_count = 0;

	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
		goto retry;

<<<<<<< HEAD
	trace_debit_entropy(r->name, 8 * ibytes);
	if (ibytes &&
	    (r->entropy_count >> ENTROPY_SHIFT) < random_write_wakeup_bits) {
=======
	trace_debit_entropy(8 * ibytes);
	if (ibytes && POOL_ENTROPY_BITS() < random_write_wakeup_bits) {
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
		wake_up_interruptible(&random_write_wait);
		kill_fasync(&fasync, SIGIO, POLL_OUT);
	}

	return ibytes;
}

/*
<<<<<<< HEAD
 * This function does the actual extraction for extract_entropy and
 * extract_entropy_user.
 *
 * Note: we assume that .poolwords is a multiple of 16 words.
 */
static void extract_buf(struct entropy_store *r, __u8 *out)
{
	int i;
	union {
		__u32 w[5];
		unsigned long l[LONGS(20)];
	} hash;
	__u32 workspace[SHA_WORKSPACE_WORDS];
=======
=======
>>>>>>> 62a2b4bd3ec9 (random: simplify entropy debiting)
 * This is an HKDF-like construction for using the hashed collected entropy
 * as a PRF key, that's then expanded block-by-block.
 */
static void extract_entropy(void *buf, size_t nbytes)
{
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
	unsigned long flags;
	u8 seed[BLAKE2S_HASH_SIZE], next_key[BLAKE2S_HASH_SIZE];
	struct {
		unsigned long rdseed[32 / sizeof(long)];
		size_t counter;
	} block;
	size_t i;

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	/*
	 * If we have an architectural hardware random number
	 * generator, use it for SHA's initial vector
	 */
	sha_init(hash.w);
	for (i = 0; i < LONGS(20); i++) {
		unsigned long v;
		if (!arch_get_random_long(&v))
			break;
		hash.l[i] = v;
	}

<<<<<<< HEAD
<<<<<<< HEAD
	/* Generate a hash across the pool, 16 words (512 bits) at a time */
	spin_lock_irqsave(&r->lock, flags);
	for (i = 0; i < r->poolinfo->poolwords; i += 16)
		sha_transform(hash.w, (__u8 *)(r->pool + i), workspace);
=======
	/* Generate a hash across the pool */
	spin_lock_irqsave(&input_pool.lock, flags);
	blake2s_update(&state, (const u8 *)input_pool_data, POOL_BYTES);
	blake2s_final(&state, hash); /* final zeros out state */
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)

	/*
	 * We mix the hash back into the pool to prevent backtracking
	 * attacks (where the attacker knows the state of the pool
	 * plus the current outputs, and attempts to find previous
	 * ouputs), unless the hash function can be inverted. By
	 * mixing at least a SHA1 worth of hash data back, we make
	 * brute-forcing the feedback as hard as brute-forcing the
	 * hash.
	 */
	__mix_pool_bytes(r, hash.w, sizeof(hash.w));
	spin_unlock_irqrestore(&r->lock, flags);

	memzero_explicit(workspace, sizeof(workspace));

	/*
	 * In case the hash function has some recognizable output
	 * pattern, we fold it in half. Thus, we always feed back
	 * twice as much data as we output.
	 */
	hash.w[0] ^= hash.w[3];
	hash.w[1] ^= hash.w[4];
	hash.w[2] ^= rol32(hash.w[2], 16);

	memcpy(out, &hash, EXTRACT_SIZE);
	memzero_explicit(&hash, sizeof(hash));
}

static ssize_t _extract_entropy(struct entropy_store *r, void *buf,
				size_t nbytes, int fips)
{
	ssize_t ret = 0, i;
	__u8 tmp[EXTRACT_SIZE];
	unsigned long flags;

	while (nbytes) {
		extract_buf(r, tmp);

		if (fips) {
			spin_lock_irqsave(&r->lock, flags);
			if (!memcmp(tmp, r->last_data, EXTRACT_SIZE))
				panic("Hardware RNG duplicated output!\n");
			memcpy(r->last_data, tmp, EXTRACT_SIZE);
			spin_unlock_irqrestore(&r->lock, flags);
		}
		i = min_t(int, nbytes, EXTRACT_SIZE);
		memcpy(buf, tmp, i);
=======
=======
	trace_extract_entropy(nbytes, POOL_ENTROPY_BITS());
=======
	trace_extract_entropy(nbytes, input_pool.entropy_count);
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)

>>>>>>> 62a2b4bd3ec9 (random: simplify entropy debiting)
	for (i = 0; i < ARRAY_SIZE(block.rdrand); ++i) {
		if (!arch_get_random_long(&block.rdrand[i]))
			block.rdrand[i] = random_get_entropy();
=======
=======
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
	for (i = 0; i < ARRAY_SIZE(block.rdseed); ++i) {
		if (!arch_get_random_seed_long(&block.rdseed[i]) &&
		    !arch_get_random_long(&block.rdseed[i]))
			block.rdseed[i] = random_get_entropy();
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
	}

	spin_lock_irqsave(&input_pool.lock, flags);

	/* seed = HASHPRF(last_key, entropy_input) */
	blake2s_final(&input_pool.hash, seed);

	/* next_key = HASHPRF(seed, RDSEED || 0) */
	block.counter = 0;
	blake2s(next_key, (u8 *)&block, seed, sizeof(next_key), sizeof(block), sizeof(seed));
	blake2s_init_key(&input_pool.hash, BLAKE2S_HASH_SIZE, next_key, sizeof(next_key));

	spin_unlock_irqrestore(&input_pool.lock, flags);
	memzero_explicit(next_key, sizeof(next_key));

	while (nbytes) {
		i = min_t(size_t, nbytes, BLAKE2S_HASH_SIZE);
		/* output = HASHPRF(seed, RDSEED || ++counter) */
		++block.counter;
		blake2s(buf, (u8 *)&block, seed, i, sizeof(block), sizeof(seed));
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
		nbytes -= i;
		buf += i;
	}

	memzero_explicit(seed, sizeof(seed));
	memzero_explicit(&block, sizeof(block));
}

<<<<<<< HEAD
<<<<<<< HEAD
/*
 * This function extracts randomness from the "entropy pool", and
 * returns it in a buffer.
 *
 * The min parameter specifies the minimum amount we can pull before
<<<<<<< HEAD
 * failing to avoid races that defeat catastrophic reseeding while the
 * reserved parameter indicates how much entropy we must leave in the
 * pool after each pull to avoid starving other readers.
 */
static ssize_t extract_entropy(struct entropy_store *r, void *buf,
				 size_t nbytes, int min, int reserved)
=======
 * failing to avoid races that defeat catastrophic reseeding. If we
 * have less than min entropy available, we return false and buf is
 * not filled.
 */
static bool extract_entropy(void *buf, size_t nbytes, int min)
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
{
<<<<<<< HEAD
	__u8 tmp[EXTRACT_SIZE];
	unsigned long flags;

	/* if last_data isn't primed, we need EXTRACT_SIZE extra bytes */
	if (fips_enabled) {
		spin_lock_irqsave(&r->lock, flags);
		if (!r->last_data_init) {
			r->last_data_init = 1;
			spin_unlock_irqrestore(&r->lock, flags);
			trace_extract_entropy(r->name, EXTRACT_SIZE,
					      ENTROPY_BITS(r), _RET_IP_);
			xfer_secondary_pool(r, EXTRACT_SIZE);
			extract_buf(r, tmp);
			spin_lock_irqsave(&r->lock, flags);
			memcpy(r->last_data, tmp, EXTRACT_SIZE);
		}
		spin_unlock_irqrestore(&r->lock, flags);
	}

	trace_extract_entropy(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
	xfer_secondary_pool(r, nbytes);
	nbytes = account(r, nbytes, min, reserved);

	return _extract_entropy(r, buf, nbytes, fips_enabled);
}

/*
 * This function extracts randomness from the "entropy pool", and
 * returns it in a userspace buffer.
 */
static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
				    size_t nbytes)
{
	ssize_t ret = 0, i;
	__u8 tmp[EXTRACT_SIZE];
	int large_request = (nbytes > 256);

	trace_extract_entropy_user(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
	xfer_secondary_pool(r, nbytes);
	nbytes = account(r, nbytes, 0, 0);

	while (nbytes) {
		if (large_request && need_resched()) {
			if (signal_pending(current)) {
				if (ret == 0)
					ret = -ERESTARTSYS;
				break;
			}
			schedule();
		}

		extract_buf(r, tmp);
		i = min_t(int, nbytes, EXTRACT_SIZE);
		if (copy_to_user(buf, tmp, i)) {
			ret = -EFAULT;
			break;
		}

		nbytes -= i;
		buf += i;
		ret += i;
	}

	/* Wipe data just returned from memory */
	memzero_explicit(tmp, sizeof(tmp));

	return ret;
=======
	trace_extract_entropy(nbytes, POOL_ENTROPY_BITS(), _RET_IP_);
<<<<<<< HEAD
	nbytes = account(nbytes, min);
	return _extract_entropy(buf, nbytes);
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
=======
	if (account(nbytes, min)) {
		_extract_entropy(buf, nbytes);
		return true;
	}
	return false;
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
}

=======
>>>>>>> 62a2b4bd3ec9 (random: simplify entropy debiting)
=======
/*
 * First we make sure we have POOL_MIN_BITS of entropy in the pool, and then we
 * set the entropy count to zero (but don't actually touch any data). Only then
 * can we extract a new key with extract_entropy().
 */
static bool drain_entropy(void *buf, size_t nbytes)
{
	unsigned int entropy_count;
	do {
		entropy_count = READ_ONCE(input_pool.entropy_count);
		if (entropy_count < POOL_MIN_BITS)
			return false;
	} while (cmpxchg(&input_pool.entropy_count, entropy_count, 0) != entropy_count);
	extract_entropy(buf, nbytes);
	wake_up_interruptible(&random_write_wait);
	kill_fasync(&fasync, SIGIO, POLL_OUT);
	return true;
}

<<<<<<< HEAD
>>>>>>> 65419e900306 (random: introduce drain_entropy() helper to declutter crng_reseed())
#define warn_unseeded_randomness(previous) \
	_warn_unseeded_randomness(__func__, (void *)_RET_IP_, (previous))

static void _warn_unseeded_randomness(const char *func_name, void *caller, void **previous)
{
#ifdef CONFIG_WARN_ALL_UNSEEDED_RANDOM
	const bool print_once = false;
#else
	static bool print_once __read_mostly;
#endif

	if (print_once || crng_ready() ||
	    (previous && (caller == READ_ONCE(*previous))))
		return;
	WRITE_ONCE(*previous, caller);
#ifndef CONFIG_WARN_ALL_UNSEEDED_RANDOM
	print_once = true;
#endif
	if (__ratelimit(&unseeded_warning))
<<<<<<< HEAD
		pr_notice("random: %s called from %pS with crng_init=%d\n",
			  func_name, caller, crng_init);
=======
		printk_deferred(KERN_NOTICE "random: %s called from %pS with crng_init=%d\n",
				func_name, caller, crng_init);
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
}

/*
 * This function is the exported kernel interface.  It returns some
 * number of good random numbers, suitable for key generation, seeding
 * TCP sequence numbers, etc.  It does not rely on the hardware random
 * number generator.  For random bytes direct from the hardware RNG
 * (when available), use get_random_bytes_arch(). In order to ensure
 * that the randomness provided by this function is okay, the function
 * wait_for_random_bytes() should be called and return 0 at least once
 * at any point prior.
 */
static void _get_random_bytes(void *buf, size_t nbytes)
{
<<<<<<< HEAD
	__u8 tmp[CHACHA20_BLOCK_SIZE];
=======
	u32 chacha_state[CHACHA20_BLOCK_SIZE / sizeof(u32)];
	u8 tmp[CHACHA20_BLOCK_SIZE];
<<<<<<< HEAD
	ssize_t len;
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
=======
	size_t len;
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

	if (!nbytes)
		return;

	len = min_t(size_t, 32, nbytes);
	crng_make_state(chacha_state, buf, len);
	nbytes -= len;
	buf += len;

	while (nbytes) {
		if (nbytes < CHACHA20_BLOCK_SIZE) {
			chacha20_block(chacha_state, tmp);
			memcpy(buf, tmp, nbytes);
			memzero_explicit(tmp, sizeof(tmp));
			break;
		}

		chacha20_block(chacha_state, buf);
		if (unlikely(chacha_state[12] == 0))
			++chacha_state[13];
		nbytes -= CHACHA20_BLOCK_SIZE;
		buf += CHACHA20_BLOCK_SIZE;
	}

	memzero_explicit(chacha_state, sizeof(chacha_state));
}

void get_random_bytes(void *buf, size_t nbytes)
{
	static void *previous;

	warn_unseeded_randomness(&previous);
	_get_random_bytes(buf, nbytes);
}
EXPORT_SYMBOL(get_random_bytes);

=======
>>>>>>> 25061d366b70 (random: group initialization wait functions)
=======
>>>>>>> 2ee36c835e91 (random: group entropy extraction functions)
=======
	/* Award one bit for the contents of the fast pool. */
	credit_entropy_bits(1);
=======
	if (new_count < 64 && !time_after(now, fast_pool->last + HZ))
		return;

	if (unlikely(!fast_pool->mix.func))
		INIT_WORK(&fast_pool->mix, mix_interrupt_randomness);
	fast_pool->count |= MIX_INFLIGHT;
	queue_work_on(raw_smp_processor_id(), system_highpri_wq, &fast_pool->mix);
>>>>>>> 80adfc1fa691 (random: defer fast pool mixing to worker)
}
EXPORT_SYMBOL_GPL(add_interrupt_randomness);

>>>>>>> 496b91b6dc44 (random: group entropy collection functions)
/*
 * Each time the timer fires, we expect that we got an unpredictable
 * jump in the cycle counter. Even if the timer is running on another
 * CPU, the timer activity will be touching the stack of the CPU that is
 * generating entropy..
 *
 * Note that we don't re-arm the timer in the timer itself - we are
 * happy to be scheduled away, since that just makes the load more
 * complex, but we do not want the timer to keep ticking unless the
 * entropy loop is running.
 *
 * So the re-arming always happens in the entropy loop itself.
 */
static void entropy_timer(unsigned long data)
{
	credit_entropy_bits(&input_pool, 1);
}

/*
 * If we have an actual cycle counter, see if we can
 * generate enough entropy with timing noise
 */
static void try_to_generate_entropy(void)
{
	struct {
		unsigned long now;
		struct timer_list timer;
	} stack;

	stack.now = random_get_entropy();

	/* Slow counter - or none. Don't even bother */
	if (stack.now == random_get_entropy())
		return;

	__setup_timer_on_stack(&stack.timer, entropy_timer, 0, 0);
	while (!crng_ready()) {
		if (!timer_pending(&stack.timer))
<<<<<<< HEAD
			mod_timer(&stack.timer, jiffies+1);
		mix_pool_bytes(&input_pool, &stack.now, sizeof(stack.now));
=======
			mod_timer(&stack.timer, jiffies + 1);
		mix_pool_bytes(&stack.now, sizeof(stack.now));
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
		schedule();
		stack.now = random_get_entropy();
	}

	del_timer_sync(&stack.timer);
	destroy_timer_on_stack(&stack.timer);
	mix_pool_bytes(&input_pool, &stack.now, sizeof(stack.now));
}

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
/*
 * Wait for the urandom pool to be seeded and thus guaranteed to supply
 * cryptographically secure random numbers. This applies to: the /dev/urandom
 * device, the get_random_bytes function, and the get_random_{u32,u64,int,long}
 * family of functions. Using any of these functions without first calling
 * this function forfeits the guarantee of security.
 *
 * Returns: 0 if the urandom pool has been seeded.
 *          -ERESTARTSYS if the function was interrupted by a signal.
 */
int wait_for_random_bytes(void)
{
	if (likely(crng_ready()))
		return 0;

	do {
		int ret;
		ret = wait_event_interruptible_timeout(crng_init_wait, crng_ready(), HZ);
		if (ret)
			return ret > 0 ? 0 : ret;

		try_to_generate_entropy();
	} while (!crng_ready());

	return 0;
}
EXPORT_SYMBOL(wait_for_random_bytes);

/*
 * Add a callback function that will be invoked when the nonblocking
 * pool is initialised.
 *
 * returns: 0 if callback is successfully added
 *	    -EALREADY if pool is already initialised (callback not called)
 *	    -ENOENT if module for callback is not alive
 */
int add_random_ready_callback(struct random_ready_callback *rdy)
{
	struct module *owner;
	unsigned long flags;
	int err = -EALREADY;

	if (crng_ready())
		return err;

	owner = rdy->owner;
	if (!try_module_get(owner))
		return -ENOENT;

	spin_lock_irqsave(&random_ready_list_lock, flags);
	if (crng_ready())
		goto out;

	owner = NULL;

	list_add(&rdy->list, &random_ready_list);
	err = 0;

out:
	spin_unlock_irqrestore(&random_ready_list_lock, flags);

	module_put(owner);

	return err;
}
EXPORT_SYMBOL(add_random_ready_callback);

/*
 * Delete a previously registered readiness callback function.
 */
void del_random_ready_callback(struct random_ready_callback *rdy)
{
	unsigned long flags;
	struct module *owner = NULL;

	spin_lock_irqsave(&random_ready_list_lock, flags);
	if (!list_empty(&rdy->list)) {
		list_del_init(&rdy->list);
		owner = rdy->owner;
	}
	spin_unlock_irqrestore(&random_ready_list_lock, flags);

	module_put(owner);
}
EXPORT_SYMBOL(del_random_ready_callback);

/*
 * This function will use the architecture-specific hardware random
<<<<<<< HEAD
 * number generator if it is available.  The arch-specific hw RNG will
 * almost certainly be faster than what we can do in software, but it
 * is impossible to verify that it is implemented securely (as
 * opposed, to, say, the AES encryption of a sequence number using a
 * key known by the NSA).  So it's useful if we need the speed, but
 * only if we're willing to trust the hardware manufacturer not to
 * have put in a back door.
 */
void get_random_bytes_arch(void *buf, int nbytes)
{
	char *p = buf;
=======
 * number generator if it is available. It is not recommended for
 * use. Use get_random_bytes() instead. It returns the number of
 * bytes filled in.
 */
size_t __must_check get_random_bytes_arch(void *buf, size_t nbytes)
{
	size_t left = nbytes;
	u8 *p = buf;
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

<<<<<<< HEAD
	trace_get_random_bytes_arch(nbytes, _RET_IP_);
	while (nbytes) {
=======
	while (left) {
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
		unsigned long v;
<<<<<<< HEAD
		int chunk = min(nbytes, (int)sizeof(unsigned long));
=======
		size_t chunk = min_t(size_t, left, sizeof(unsigned long));
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

		if (!arch_get_random_long(&v))
			break;

		memcpy(p, &v, chunk);
		p += chunk;
		nbytes -= chunk;
	}

	if (nbytes)
		get_random_bytes(p, nbytes);
}
EXPORT_SYMBOL(get_random_bytes_arch);

<<<<<<< HEAD

/*
 * init_std_data - initialize pool with system data
 *
 * @r: pool to initialize
 *
 * This function clears the pool's entropy count and mixes some system
 * data into the pool to prepare it for use. The pool is not cleared
 * as that can only decrease the entropy in the pool.
 */
static void init_std_data(struct entropy_store *r)
{
	int i;
	ktime_t now = ktime_get_real();
	unsigned long rv;

<<<<<<< HEAD
	r->last_pulled = jiffies;
	mix_pool_bytes(r, &now, sizeof(now));
	for (i = r->poolinfo->poolbytes; i > 0; i -= sizeof(rv)) {
=======
	mix_pool_bytes(&now, sizeof(now));
	for (i = BLAKE2S_BLOCK_SIZE; i > 0; i -= sizeof(rv)) {
>>>>>>> ccf535b5077a (random: use computational hash for entropy extraction)
		if (!arch_get_random_seed_long(&rv) &&
		    !arch_get_random_long(&rv))
			rv = random_get_entropy();
		mix_pool_bytes(r, &rv, sizeof(rv));
	}
	mix_pool_bytes(r, utsname(), sizeof(*(utsname())));
=======
=======
>>>>>>> 25061d366b70 (random: group initialization wait functions)
static bool trust_cpu __ro_after_init = IS_ENABLED(CONFIG_RANDOM_TRUST_CPU);
static int __init parse_trust_cpu(char *arg)
{
	return kstrtobool(arg, &trust_cpu);
>>>>>>> 13c423b6b1d3 (random: inline leaves of rand_initialize())
}
early_param("random.trust_cpu", parse_trust_cpu);

/*
 * Note that setup_arch() may call add_device_randomness()
 * long before we get here. This allows seeding of the pools
 * with some platform dependent data very early in the boot
 * process. But it limits our options here. We must use
 * statically allocated structures that already have all
 * initializations complete at compile time. We should also
 * take care not to overwrite the precious per platform data
 * we were given.
 */
static int rand_initialize(void)
{
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	init_std_data(&input_pool);
	init_std_data(&blocking_pool);
	crng_initialize(&primary_crng);
=======
	init_std_data();
<<<<<<< HEAD
	if (crng_need_final_init)
		crng_finalize_init();
	crng_initialize_primary();
>>>>>>> 7beef135045b (random: access primary_pool directly rather than through pointer)
	crng_global_init_time = jiffies;
=======
	crng_initialize();
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
=======
	int i;
=======
	size_t i;
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
	ktime_t now = ktime_get_real();
	bool arch_init = true;
	unsigned long rv;

	for (i = 0; i < BLAKE2S_BLOCK_SIZE; i += sizeof(rv)) {
		if (!arch_get_random_seed_long_early(&rv) &&
		    !arch_get_random_long_early(&rv)) {
			rv = random_get_entropy();
			arch_init = false;
		}
		mix_pool_bytes(&rv, sizeof(rv));
	}
	mix_pool_bytes(&now, sizeof(now));
	mix_pool_bytes(utsname(), sizeof(*(utsname())));

	extract_entropy(base_crng.key, sizeof(base_crng.key));
	++base_crng.generation;

	if (arch_init && trust_cpu && crng_init < 2) {
		crng_init = 2;
		pr_notice("crng init done (trusting CPU's manufacturer)\n");
	}

>>>>>>> 13c423b6b1d3 (random: inline leaves of rand_initialize())
	if (ratelimit_disable) {
		urandom_warning.interval = 0;
		unseeded_warning.interval = 0;
	}
	return 0;
}
early_initcall(rand_initialize);

#ifdef CONFIG_BLOCK
void rand_initialize_disk(struct gendisk *disk)
{
	struct timer_rand_state *state;

	/*
	 * If kzalloc returns null, we just won't use that entropy
	 * source.
	 */
	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
	if (state) {
		state->last_time = INITIAL_JIFFIES;
		disk->random = state;
	}
}
#endif

<<<<<<< HEAD
<<<<<<< HEAD
static ssize_t
_random_read(int nonblock, char __user *buf, size_t nbytes)
=======
static ssize_t urandom_read_nowarn(struct file *file, char __user *buf,
				   size_t nbytes, loff_t *ppos)
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
{
<<<<<<< HEAD
	ssize_t n;

<<<<<<< HEAD
<<<<<<< HEAD
	if (nbytes == 0)
		return 0;
=======
	nbytes = min_t(size_t, nbytes, INT_MAX >> (POOL_ENTROPY_SHIFT + 3));
=======
	nbytes = min_t(size_t, nbytes, INT_MAX >> 6);
<<<<<<< HEAD
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
	ret = extract_crng_user(buf, nbytes);
=======
=======
	ssize_t ret;

>>>>>>> 21682884c699 (random: remove outdated INT_MAX >> 6 check in urandom_read())
	ret = get_random_bytes_user(buf, nbytes);
<<<<<<< HEAD
>>>>>>> 5a595c18329e (random: absorb fast pool into input pool after fast load)
	trace_urandom_read(8 * nbytes, 0, input_pool.entropy_count);
=======
	trace_urandom_read(nbytes, input_pool.entropy_count);
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
	return ret;
}
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)

<<<<<<< HEAD
	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
	while (1) {
		n = extract_entropy_user(&blocking_pool, buf, nbytes);
		if (n < 0)
			return n;
		trace_random_read(n*8, (nbytes-n)*8,
				  ENTROPY_BITS(&blocking_pool),
				  ENTROPY_BITS(&input_pool));
		if (n > 0)
			return n;
=======
=======
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
=======
>>>>>>> 496b91b6dc44 (random: group entropy collection functions)
static ssize_t urandom_read(struct file *file, char __user *buf, size_t nbytes,
			    loff_t *ppos)
{
	static int maxwarn = 10;
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)

		/* Pool is (near) empty.  Maybe wait and retry. */
		if (nonblock)
			return -EAGAIN;

		wait_event_interruptible(random_read_wait,
			ENTROPY_BITS(&input_pool) >=
			random_read_wakeup_bits);
		if (signal_pending(current))
			return -ERESTARTSYS;
	}
<<<<<<< HEAD
=======

	return get_random_bytes_user(buf, nbytes);
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
}

static ssize_t random_read(struct file *file, char __user *buf, size_t nbytes,
			   loff_t *ppos)
{
	return _random_read(file->f_flags & O_NONBLOCK, buf, nbytes);
}

static ssize_t
urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
{
	unsigned long flags;
	static int maxwarn = 10;
	int ret;

<<<<<<< HEAD
	if (!crng_ready() && maxwarn > 0) {
		maxwarn--;
		if (__ratelimit(&urandom_warning))
			printk(KERN_NOTICE "random: %s: uninitialized "
			       "urandom read (%zd bytes read)\n",
			       current->comm, nbytes);
		spin_lock_irqsave(&primary_crng.lock, flags);
		crng_init_cnt = 0;
		spin_unlock_irqrestore(&primary_crng.lock, flags);
	}
	nbytes = min_t(size_t, nbytes, INT_MAX >> (ENTROPY_SHIFT + 3));
	ret = extract_crng_user(buf, nbytes);
	trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(&input_pool));
	return ret;
=======
	ret = wait_for_random_bytes();
	if (ret != 0)
		return ret;
	return get_random_bytes_user(buf, nbytes);
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
=======

/**********************************************************************
 *
 * Userspace reader/writer interfaces.
 *
 * getrandom(2) is the primary modern interface into the RNG and should
 * be used in preference to anything else.
 *
 * Reading from /dev/random has the same functionality as calling
 * getrandom(2) with flags=0. In earlier versions, however, it had
 * vastly different semantics and should therefore be avoided, to
 * prevent backwards compatibility issues.
 *
 * Reading from /dev/urandom has the same functionality as calling
 * getrandom(2) with flags=GRND_INSECURE. Because it does not block
 * waiting for the RNG to be ready, it should not be used.
 *
 * Writing to either /dev/random or /dev/urandom adds entropy to
 * the input pool but does not credit it.
 *
 * Polling on /dev/random indicates when the RNG is initialized, on
 * the read side, and when it wants new entropy, on the write side.
 *
 * Both /dev/random and /dev/urandom have the same set of ioctls for
 * adding entropy, getting the entropy count, zeroing the count, and
 * reseeding the crng.
 *
 **********************************************************************/

SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count, unsigned int,
		flags)
{
	if (flags & ~(GRND_NONBLOCK | GRND_RANDOM | GRND_INSECURE))
		return -EINVAL;

	/*
	 * Requesting insecure and blocking randomness at the same time makes
	 * no sense.
	 */
	if ((flags & (GRND_INSECURE | GRND_RANDOM)) == (GRND_INSECURE | GRND_RANDOM))
		return -EINVAL;

	if (count > INT_MAX)
		count = INT_MAX;

	if (!(flags & GRND_INSECURE) && !crng_ready()) {
		int ret;

		if (flags & GRND_NONBLOCK)
			return -EAGAIN;
		ret = wait_for_random_bytes();
		if (unlikely(ret))
			return ret;
	}
	return get_random_bytes_user(buf, count);
>>>>>>> c3502a795f6a (random: group userspace read/write functions)
}

static unsigned int random_poll(struct file *file, poll_table *wait)
{
	unsigned int mask;

	poll_wait(file, &random_read_wait, wait);
	poll_wait(file, &random_write_wait, wait);
	mask = 0;
	if (ENTROPY_BITS(&input_pool) >= random_read_wakeup_bits)
		mask |= POLLIN | POLLRDNORM;
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	if (ENTROPY_BITS(&input_pool) < random_write_wakeup_bits)
=======
	if (POOL_ENTROPY_BITS() < random_write_wakeup_bits)
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
=======
	if (input_pool.entropy_count < random_write_wakeup_bits)
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
=======
	if (input_pool.entropy_count < POOL_MIN_BITS)
>>>>>>> f82262f273f1 (random: always wake up entropy writers after extraction)
		mask |= POLLOUT | POLLWRNORM;
	return mask;
}

<<<<<<< HEAD
<<<<<<< HEAD
static int
write_pool(struct entropy_store *r, const char __user *buffer, size_t count)
=======
static int write_pool(const char __user *buffer, size_t count)
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
{
	size_t bytes;
<<<<<<< HEAD
	__u32 t, buf[16];
=======
	u8 buf[BLAKE2S_BLOCK_SIZE];
>>>>>>> 2d9c1b42a51c (random: do not xor RDRAND when writing into /dev/random)
	const char __user *p = buffer;
=======
static int write_pool(const char __user *ubuf, size_t count)
{
	size_t len;
	int ret = 0;
	u8 block[BLAKE2S_BLOCK_SIZE];
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())

	while (count) {
		len = min(count, sizeof(block));
<<<<<<< HEAD
		if (copy_from_user(block, ubuf, len))
			return -EFAULT;
<<<<<<< HEAD
<<<<<<< HEAD

		for (b = bytes ; b > 0 ; b -= sizeof(__u32), i++) {
			if (!arch_get_random_int(&t))
				break;
			buf[i] ^= t;
		}

		count -= bytes;
		p += bytes;

		mix_pool_bytes(r, buf, bytes);
=======
		count -= bytes;
		p += bytes;
		mix_pool_bytes(buf, bytes);
>>>>>>> 2d9c1b42a51c (random: do not xor RDRAND when writing into /dev/random)
=======
=======
		if (copy_from_user(block, ubuf, len)) {
			ret = -EFAULT;
			goto out;
		}
>>>>>>> 93ce4028c4e2 (random: zero buffer after reading entropy from userspace)
		count -= len;
		ubuf += len;
		mix_pool_bytes(block, len);
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
		cond_resched();
	}

out:
	memzero_explicit(block, sizeof(block));
	return ret;
}

static ssize_t random_write(struct file *file, const char __user *buffer,
			    size_t count, loff_t *ppos)
{
	int ret;

	ret = write_pool(&input_pool, buffer, count);
	if (ret)
		return ret;

	return (ssize_t)count;
}

static ssize_t urandom_read(struct file *file, char __user *buf, size_t nbytes,
			    loff_t *ppos)
{
	static int maxwarn = 10;

	if (!crng_ready() && maxwarn > 0) {
		maxwarn--;
		if (__ratelimit(&urandom_warning))
			pr_notice("%s: uninitialized urandom read (%zd bytes read)\n",
				  current->comm, nbytes);
	}

	return get_random_bytes_user(buf, nbytes);
}

static ssize_t random_read(struct file *file, char __user *buf, size_t nbytes,
			   loff_t *ppos)
{
	int ret;

	ret = wait_for_random_bytes();
	if (ret != 0)
		return ret;
	return get_random_bytes_user(buf, nbytes);
}

static long random_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
	int size, ent_count;
	int __user *p = (int __user *)arg;
	int retval;

	switch (cmd) {
	case RNDGETENTCNT:
<<<<<<< HEAD
		/* inherently racy, no point locking */
<<<<<<< HEAD
<<<<<<< HEAD
		ent_count = ENTROPY_BITS(&input_pool);
=======
		ent_count = POOL_ENTROPY_BITS();
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
		if (put_user(ent_count, p))
=======
=======
		/* Inherently racy, no point locking. */
>>>>>>> c3502a795f6a (random: group userspace read/write functions)
		if (put_user(input_pool.entropy_count, p))
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
			return -EFAULT;
		return 0;
	case RNDADDTOENTCNT:
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (get_user(ent_count, p))
			return -EFAULT;
<<<<<<< HEAD
		return credit_entropy_bits_safe(&input_pool, ent_count);
=======
		if (ent_count < 0)
			return -EINVAL;
		credit_entropy_bits(ent_count);
		return 0;
>>>>>>> 6605171cd8cb (random: make credit_entropy_bits() always safe)
	case RNDADDENTROPY:
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (get_user(ent_count, p++))
			return -EFAULT;
		if (ent_count < 0)
			return -EINVAL;
		if (get_user(size, p++))
			return -EFAULT;
		retval = write_pool(&input_pool, (const char __user *)p,
				    size);
		if (retval < 0)
			return retval;
<<<<<<< HEAD
		return credit_entropy_bits_safe(&input_pool, ent_count);
=======
		credit_entropy_bits(ent_count);
		return 0;
>>>>>>> 6605171cd8cb (random: make credit_entropy_bits() always safe)
	case RNDZAPENTCNT:
	case RNDCLEARPOOL:
		/*
		 * Clear the entropy pool counters. We no longer clear
		 * the entropy pool, as that's silly.
		 */
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
<<<<<<< HEAD
<<<<<<< HEAD
		input_pool.entropy_count = 0;
		blocking_pool.entropy_count = 0;
=======
		if (xchg(&input_pool.entropy_count, 0)) {
=======
		if (xchg(&input_pool.entropy_count, 0) >= POOL_MIN_BITS) {
>>>>>>> 430374f42c21 (random: only wake up writers after zap if threshold was passed)
			wake_up_interruptible(&random_write_wait);
			kill_fasync(&fasync, SIGIO, POLL_OUT);
		}
>>>>>>> f82262f273f1 (random: always wake up entropy writers after extraction)
		return 0;
	case RNDRESEEDCRNG:
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (crng_init < 2)
			return -ENODATA;
<<<<<<< HEAD
<<<<<<< HEAD
		crng_reseed(&primary_crng, &input_pool);
=======
		crng_reseed(&primary_crng);
>>>>>>> 8c39bfd9db3c (random: remove use_input_pool parameter from crng_reseed())
		WRITE_ONCE(crng_global_init_time, jiffies - 1);
=======
		crng_reseed();
>>>>>>> d0841f7e4ae6 (random: use RDSEED instead of RDRAND in entropy extraction)
		return 0;
	default:
		return -EINVAL;
	}
}

static int random_fasync(int fd, struct file *filp, int on)
{
	return fasync_helper(fd, filp, on, &fasync);
}

const struct file_operations random_fops = {
	.read = random_read,
	.write = random_write,
	.poll = random_poll,
	.unlocked_ioctl = random_ioctl,
	.fasync = random_fasync,
	.llseek = noop_llseek,
};

const struct file_operations urandom_fops = {
	.read = urandom_read,
	.write = random_write,
	.unlocked_ioctl = random_ioctl,
	.fasync = random_fasync,
	.llseek = noop_llseek,
};

<<<<<<< HEAD
<<<<<<< HEAD
SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count, unsigned int,
		flags)
{
<<<<<<< HEAD
	int ret;

<<<<<<< HEAD
	if (flags & ~(GRND_NONBLOCK|GRND_RANDOM))
=======
=======
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
	if (flags & ~(GRND_NONBLOCK | GRND_RANDOM | GRND_INSECURE))
		return -EINVAL;

	/*
	 * Requesting insecure and blocking randomness at the same time makes
	 * no sense.
	 */
	if ((flags & (GRND_INSECURE | GRND_RANDOM)) == (GRND_INSECURE | GRND_RANDOM))
>>>>>>> 166f9970b82a (random: access input_pool_data directly rather than through pointer)
		return -EINVAL;

	if (count > INT_MAX)
		count = INT_MAX;

<<<<<<< HEAD
	if (flags & GRND_RANDOM)
		return _random_read(flags & GRND_NONBLOCK, buf, count);

	if (!crng_ready()) {
=======
	if (!(flags & GRND_INSECURE) && !crng_ready()) {
		int ret;

>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
		if (flags & GRND_NONBLOCK)
			return -EAGAIN;
		ret = wait_for_random_bytes();
		if (unlikely(ret))
			return ret;
	}
<<<<<<< HEAD
	return urandom_read(NULL, buf, count, NULL);
=======
	return get_random_bytes_user(buf, count);
>>>>>>> 707c01fe19eb (random: remove unused tracepoints)
}

=======
>>>>>>> c3502a795f6a (random: group userspace read/write functions)
=======

>>>>>>> 57332ead20e1 (random: group sysctl functions)
/********************************************************************
 *
 * Sysctl interface.
 *
 * These are partly unused legacy knobs with dummy values to not break
 * userspace and partly still useful things. They are usually accessible
 * in /proc/sys/kernel/random/ and are as follows:
 *
 * - boot_id - a UUID representing the current boot.
 *
 * - uuid - a random UUID, different each time the file is read.
 *
 * - poolsize - the number of bits of entropy that the input pool can
 *   hold, tied to the POOL_BITS constant.
 *
 * - entropy_avail - the number of bits of entropy currently in the
 *   input pool. Always <= poolsize.
 *
 * - write_wakeup_threshold - the amount of entropy in the input pool
 *   below which write polls to /dev/random will unblock, requesting
 *   more entropy, tied to the POOL_MIN_BITS constant. It is writable
 *   to avoid breaking old userspaces, but writing to it does not
 *   change any behavior of the RNG.
 *
 * - urandom_min_reseed_secs - fixed to the meaningless value "60".
 *   It is writable to avoid breaking old userspaces, but writing
 *   to it does not change any behavior of the RNG.
 *
 ********************************************************************/

#ifdef CONFIG_SYSCTL

#include <linux/sysctl.h>

<<<<<<< HEAD
<<<<<<< HEAD
static int min_read_thresh = 8, min_write_thresh;
static int max_read_thresh = OUTPUT_POOL_WORDS * 32;
static int max_write_thresh = INPUT_POOL_WORDS * 32;
=======
>>>>>>> f82262f273f1 (random: always wake up entropy writers after extraction)
static int random_min_urandom_seed = 60;
static int random_write_wakeup_bits = POOL_MIN_BITS;
=======
static int sysctl_random_min_urandom_seed = 60;
static int sysctl_random_write_wakeup_bits = POOL_MIN_BITS;
>>>>>>> 57332ead20e1 (random: group sysctl functions)
static int sysctl_poolsize = POOL_BITS;
static u8 sysctl_bootid[UUID_SIZE];

/*
 * This function is used to return both the bootid UUID, and random
 * UUID. The difference is in whether table->data is NULL; if it is,
 * then a new UUID is generated and returned to the user.
 */
static int proc_do_uuid(struct ctl_table *table, int write,
			void __user *buffer, size_t *lenp, loff_t *ppos)
{
	u8 tmp_uuid[UUID_SIZE], *uuid;
	char uuid_string[UUID_STRING_LEN + 1];
	struct ctl_table fake_table = {
		.data = uuid_string,
		.maxlen = UUID_STRING_LEN
	};

	if (write)
		return -EPERM;

	uuid = table->data;
	if (!uuid) {
		uuid = tmp_uuid;
		generate_random_uuid(uuid);
	} else {
		static DEFINE_SPINLOCK(bootid_spinlock);

		spin_lock(&bootid_spinlock);
		if (!uuid[8])
			generate_random_uuid(uuid);
		spin_unlock(&bootid_spinlock);
	}

	snprintf(uuid_string, sizeof(uuid_string), "%pU", uuid);
	return proc_dostring(&fake_table, 0, buffer, lenp, ppos);
}

<<<<<<< HEAD
<<<<<<< HEAD
/*
 * Return entropy available scaled to integral bits
 */
static int proc_do_entropy(struct ctl_table *table, int write,
			   void __user *buffer, size_t *lenp, loff_t *ppos)
{
	struct ctl_table fake_table;
	int entropy_count;

	entropy_count = *(int *)table->data >> POOL_ENTROPY_SHIFT;

	fake_table.data = &entropy_count;
	fake_table.maxlen = sizeof(entropy_count);

	return proc_dointvec(&fake_table, write, buffer, lenp, ppos);
}

static int sysctl_poolsize = INPUT_POOL_WORDS * 32;
=======
static int sysctl_poolsize = POOL_BITS;
>>>>>>> bb375abdbf11 (random: use linear min-entropy accumulation crediting)
=======
>>>>>>> f82262f273f1 (random: always wake up entropy writers after extraction)
extern struct ctl_table random_table[];
struct ctl_table random_table[] = {
	{
		.procname	= "poolsize",
		.data		= &sysctl_poolsize,
		.maxlen		= sizeof(int),
		.mode		= 0444,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "entropy_avail",
		.data		= &input_pool.entropy_count,
		.maxlen		= sizeof(int),
		.mode		= 0444,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "read_wakeup_threshold",
		.data		= &random_read_wakeup_bits,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec_minmax,
		.extra1		= &min_read_thresh,
		.extra2		= &max_read_thresh,
	},
	{
		.procname	= "write_wakeup_threshold",
		.data		= &sysctl_random_write_wakeup_bits,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "urandom_min_reseed_secs",
		.data		= &sysctl_random_min_urandom_seed,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "boot_id",
		.data		= &sysctl_bootid,
		.mode		= 0444,
		.proc_handler	= proc_do_uuid,
	},
	{
		.procname	= "uuid",
		.mode		= 0444,
		.proc_handler	= proc_do_uuid,
	},
	{ }
};
#endif	/* CONFIG_SYSCTL */
<<<<<<< HEAD

/* Interface for in-kernel drivers of true hardware RNGs.
 * Those devices may produce endless random bits and will be throttled
 * when our pool is full.
 */
void add_hwgenerator_randomness(const void *buffer, size_t count,
				size_t entropy)
{
	struct entropy_store *poolp = &input_pool;

	if (unlikely(crng_init == 0)) {
		crng_fast_load(buffer, count);
		return;
	}

	/* Throttle writing if we're above the trickle threshold.
	 * We'll be woken up again once below POOL_MIN_BITS, when
	 * the calling thread is about to terminate, or once
	 * CRNG_RESEED_INTERVAL has elapsed.
	 */
<<<<<<< HEAD
<<<<<<< HEAD
	wait_event_freezable(random_write_wait, kthread_should_stop() ||
			ENTROPY_BITS(&input_pool) <= random_write_wakeup_bits);
	mix_pool_bytes(poolp, buffer, count);
	credit_entropy_bits(poolp, entropy);
=======
	wait_event_interruptible(random_write_wait,
=======
	wait_event_interruptible_timeout(random_write_wait,
>>>>>>> 35e312919dd9 (random: continually use hwgenerator randomness)
			!system_wq || kthread_should_stop() ||
			input_pool.entropy_count < POOL_MIN_BITS,
			CRNG_RESEED_INTERVAL);
	mix_pool_bytes(buffer, count);
	credit_entropy_bits(entropy);
>>>>>>> a88fa6c02cb1 (random: prepend remaining pool constants with POOL_)
}
EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);
<<<<<<< HEAD
=======

/* Handle random seed passed by bootloader.
 * If the seed is trustworthy, it would be regarded as hardware RNGs. Otherwise
 * it would be regarded as device data.
 * The decision is controlled by CONFIG_RANDOM_TRUST_BOOTLOADER.
 */
void add_bootloader_randomness(const void *buf, size_t size)
{
	if (IS_ENABLED(CONFIG_RANDOM_TRUST_BOOTLOADER))
		add_hwgenerator_randomness(buf, size, size * 8);
	else
		add_device_randomness(buf, size);
}
EXPORT_SYMBOL_GPL(add_bootloader_randomness);
>>>>>>> acbf6f4851e3 (random: use hash function for crng_slow_load())
=======
>>>>>>> 496b91b6dc44 (random: group entropy collection functions)
